"use strict";var _=Object.create;var h=Object.defineProperty;var k=Object.getOwnPropertyDescriptor;var P=Object.getOwnPropertyNames;var A=Object.getPrototypeOf,R=Object.prototype.hasOwnProperty;var H=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),W=(r,e)=>{for(var t in e)h(r,t,{get:e[t],enumerable:!0})},w=(r,e,t,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let u of P(e))!R.call(r,u)&&u!==t&&h(r,u,{get:()=>e[u],enumerable:!(s=k(e,u))||s.enumerable});return r};var m=(r,e,t)=>(t=r!=null?_(A(r)):{},w(e||!r||!r.__esModule?h(t,"default",{value:r,enumerable:!0}):t,r)),T=r=>w(h({},"__esModule",{value:!0}),r);var $=H((xr,d)=>{var D=require("node:tty"),G=D?.WriteStream?.prototype?.hasColors?.()??!1,n=(r,e)=>{if(!G)return u=>u;let t=`\x1B[${r}m`,s=`\x1B[${e}m`;return u=>{let g=u+"",l=g.indexOf(s);if(l===-1)return t+g+s;let b=t,f=0,C=(e===22?s:"")+t;for(;l!==-1;)b+=g.slice(f,l)+C,f=l+s.length,l=g.indexOf(s,f);return b+=g.slice(f)+s,b}},o={};o.reset=n(0,0);o.bold=n(1,22);o.dim=n(2,22);o.italic=n(3,23);o.underline=n(4,24);o.overline=n(53,55);o.inverse=n(7,27);o.hidden=n(8,28);o.strikethrough=n(9,29);o.black=n(30,39);o.red=n(31,39);o.green=n(32,39);o.yellow=n(33,39);o.blue=n(34,39);o.magenta=n(35,39);o.cyan=n(36,39);o.white=n(37,39);o.gray=n(90,39);o.bgBlack=n(40,49);o.bgRed=n(41,49);o.bgGreen=n(42,49);o.bgYellow=n(43,49);o.bgBlue=n(44,49);o.bgMagenta=n(45,49);o.bgCyan=n(46,49);o.bgWhite=n(47,49);o.bgGray=n(100,49);o.redBright=n(91,39);o.greenBright=n(92,39);o.yellowBright=n(93,39);o.blueBright=n(94,39);o.magentaBright=n(95,39);o.cyanBright=n(96,39);o.whiteBright=n(97,39);o.bgRedBright=n(101,49);o.bgGreenBright=n(102,49);o.bgYellowBright=n(103,49);o.bgBlueBright=n(104,49);o.bgMagentaBright=n(105,49);o.bgCyanBright=n(106,49);o.bgWhiteBright=n(107,49);d.exports=o});var mr={};W(mr,{CurrentBranch:()=>S,PreviousBranch:()=>L,addAll:()=>pr,changeWorkingDirectory:()=>N,checkout:()=>V,checkoutOrCreate:()=>X,clean:()=>ar,clone:()=>z,commitEverything:()=>cr,commitPath:()=>lr,deleteBranch:()=>y,deleteLocalAndRemoteBranch:()=>rr,didFileChangedSince:()=>sr,fetch:()=>tr,getCommitSha:()=>q,getFirstCommit:()=>U,getRelativePath:()=>Y,getRemote:()=>M,hardReset:()=>or,hasRemoteBranch:()=>er,hasTag:()=>ir,hasUncommittedChanges:()=>F,isGitInstalled:()=>E,isInsideWorkTree:()=>j,isLocalHeadAheadOfRemote:()=>nr,listCommits:()=>br,merge:()=>fr,pull:()=>O,push:()=>ur,readConfig:()=>J,restoreAllStaged:()=>wr,setLocalConfig:()=>K,setRemote:()=>Z,tagCurrentCommit:()=>gr,tags:()=>hr,useSparseCheckoutCone:()=>Q});module.exports=T(mr);var p=require("child_process");var a=m($());var vr=(0,a.blue)((0,a.dim)("internal only"));function x(r,e,t){console.log(I[r]+e),typeof t?.exit<"u"&&process.exit(t.exit)}var I={wait:`\u{1F550}${(0,a.blue)("wait")}  - `,info:`${process.env.GITHUB_ACTIONS==="true"?"\u2139\uFE0F":"\u2139\uFE0F "}${(0,a.cyan)("info")}  - `,success:`\u2705${(0,a.green)("ready")}  - `,warn:`${process.env.GITHUB_ACTIONS==="true"?"\u26A0\uFE0F":"\u26A0\uFE0F "}${(0,a.yellow)("warn")}  - `,error:`\u{1F4A5}${(0,a.red)("error")}  - `,event:`\u26A1\uFE0F${(0,a.magenta)("event")}  - `,paymentPrompt:`\u{1F4B0}${(0,a.yellowBright)("plan")}  - `};var v=m(require("path")),S=".",L="-",c;function N(r){c=r}function i(r,e){return new Promise((t,s)=>{e.verbose&&console.log(`Running git command${c?` in ${c}`:"in current directory"}: ${r}`),(0,p.exec)(r,{cwd:c},(u,g,l)=>{if(e.throwOnError&&u){s(new Error(`failed running git ${u.message.replace(/oauth2:gho_[a-zA-Z0-9]+@/g,"oauth2:gho_xxxxx")}
${g.trim()}
${l.trim()}`));return}e.verbose&&console.log(`${g.trim()}
${l.trim()}`),t(g.trim())})})}async function U(r){let t=(await i("git rev-list --max-parents=0 HEAD",{...r,throwOnError:!0})).split(/\r?\n/).filter(Boolean);return t[t.length-1]}function E(){return new Promise(r=>{(0,p.exec)("git --version",e=>{r(e===null)})})}async function j(r){return await E()?await i("git rev-parse --is-inside-work-tree",{...r,throwOnError:!1})==="true":(x("info","git is not installed"),!1)}async function F(r){return(await i("git status --porcelain=2",{...r,throwOnError:!0})).split(`
`).filter(s=>s.startsWith("1")||s.startsWith("2")||s.startsWith("u")||s.startsWith("?")).length>0}async function M(r){return await B(r)?(await i("git remote get-url origin",{...r,throwOnError:!1})).replace(/\.[^./]+$/,""):""}function Y(r){return i("git rev-parse --show-prefix",{...r,throwOnError:!0})}async function q(r){return await B(r)?i("git rev-parse HEAD",{...r,throwOnError:!0}):""}async function z(r,e,t){c=v.default.dirname(e),await i(`git clone --filter=blob:none --no-checkout ${r} "${e}"`,{...t,throwOnError:!0})}async function Z(r,e,t){try{await i(`git remote set-url ${r} ${e}`,{...t,throwOnError:!0})}catch{await i(`git remote add ${r} ${e}`,{...t,throwOnError:!0})}}function J(r,e){return i(`git config --get ${r}`,{...e,throwOnError:!0})}function K(r,e,t){return i(`git config --local ${r} "${e}"`,{...t,throwOnError:!0})}function Q(r,e){return i(`git sparse-checkout set ${r}`,{...e,throwOnError:!0})}function V(r,e){return i(`git checkout ${r}`,{...e,throwOnError:!0})}function X(r,e){return i(`git checkout -b ${r} || git checkout ${r}`,{...e,throwOnError:!0})}function y(r,e){return i(`git branch -D ${r}`,{...e,throwOnError:!1})}async function rr(r,e){return await y(r,e),i(`git push origin -d ${r}`,{...e,throwOnError:!1})}async function er(r,e){return await i(`git ls-remote --heads origin ${r}`,{...e,throwOnError:!1})!==""}function tr(r,e,t){return i(`git fetch ${r} ${e} --depth=1`,{...t,throwOnError:!1})}function or(r,e){return i(`git reset --hard ${r}`,{...e,throwOnError:!0})}async function nr(r,e){let t=await i(`git rev-parse ${r}`,{...e,throwOnError:!0}),s=await i(`git rev-parse origin/${r}`,{...e,throwOnError:!0});return t===s?!0:await i(`git merge-base --is-ancestor ${s} ${t} && echo "success"`,{...e,throwOnError:!1})==="success"}async function ir(r,e){return await i(`git tag -l ${r}`,{...e,throwOnError:!1})!==""}async function sr(r,e,t){return await i(`git diff HEAD..${e} -- "${r}"`,{...t,throwOnError:!0})!==""}function ar(r){return i("git clean -fd",{...r,throwOnError:!0})}function ur(r,e){return i(`git push -u origin ${r}`,{...e,throwOnError:!0})}function gr(r,e,t){return i(`git tag -f -a ${r} -m "${e}"`,{...t,throwOnError:!0})}function lr(r,e,t){return i(`git add "${r}" && git commit -m "${e}"`,{...t,throwOnError:!0})}function cr(r,e){return i(`git add . && git commit -m "${r}"`,{...e,throwOnError:!0})}async function O(r,e){try{return await i(`git pull origin ${r} --ff`,{...e,throwOnError:!0})}catch(t){if(t instanceof Error&&t.message.includes("fatal: refusing to merge unrelated histories"))return await i("git fetch --deepen=1",{...e,throwOnError:!0}),await O(r,e);throw t}}function fr(r,e){return i(`git merge ${r}`,{...e,throwOnError:!0})}function hr(r){return{latestPullTag:"__raycast_latest_pull_"+r+"__",latestPublishTag:"__raycast_latest_publish_"+r+"__"}}async function br(r,e){return(await i(`git log --pretty=format:%s${r?` HEAD...${r}`:""}`,{...e,throwOnError:!0})).split(`
`)}async function pr(r){return i("git add .",{...r,throwOnError:!0})}async function wr(r){return i("git restore --staged .",{...r,throwOnError:!0})}async function B(r){try{return await i("git remote get-url origin",{...r,throwOnError:!1}),!0}catch{return!1}}0&&(module.exports={CurrentBranch,PreviousBranch,addAll,changeWorkingDirectory,checkout,checkoutOrCreate,clean,clone,commitEverything,commitPath,deleteBranch,deleteLocalAndRemoteBranch,didFileChangedSince,fetch,getCommitSha,getFirstCommit,getRelativePath,getRemote,hardReset,hasRemoteBranch,hasTag,hasUncommittedChanges,isGitInstalled,isInsideWorkTree,isLocalHeadAheadOfRemote,listCommits,merge,pull,push,readConfig,restoreAllStaged,setLocalConfig,setRemote,tagCurrentCommit,tags,useSparseCheckoutCone});
