import * as viem from 'viem';
import { Hex, Address, WalletClient, Transport, Chain, PublicActions } from 'viem';
import { PrivateKeyAccount, Address as Address$1 } from 'viem/accounts';
import { Erc7811Actions } from 'viem/experimental';

declare const PYTH_CONTRACT: {
    readonly mainnet: "0xA2aa501b19aff244D90cc15a4Cf739D2725B5729";
    readonly testnet: "0x98046Bd286715D3B0BC227Dd7a956b83D8978603";
};
declare const HERMES_ENDPOINT: {
    readonly mainnet: "https://hermes.pyth.network";
    readonly testnet: "https://hermes.pyth.network";
};
declare const PYTH_PRICE_FEED_IDS: {
    readonly "BTC/USD": "e62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43";
    readonly "ETH/USD": "ff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace";
    readonly "SOL/USD": "ef0d8b6fda2ceba41da15d4095d1da392a0d2f8ed0c6c7bc0f4cfac8c280b56d";
    readonly "BNB/USD": "2f95862b045670cd22bee3114c39763a4a08beeb663b145d283c31d7d1101c4f";
    readonly "XRP/USD": "ec5d399846a9209f3fe5881d70aae9268c94339ff9817e8d18ff19fa05eea1c8";
    readonly "ADA/USD": "2a01deaec9e51a579277b34b122399984d0bbf57e2458a7e42fecd2829867a0d";
    readonly "DOGE/USD": "dcef50dd0a4cd2dcc17e45df1676dcb336a11a61c69df7a0299b0150c672d25c";
    readonly "DOT/USD": "ca3eed9b267293f6595901c734c7525ce8ef49adafe8284571c8e17d6c926346";
    readonly "AVAX/USD": "93da3352f9f1d105fdfe4971cfa80e9dd777bfc5d0f683ebb6e1294b92137bb7";
    readonly "MATIC/USD": "5de33440f6b7d0d7d70f0a7b2a6c0e0b8e5d2f7c8a9b0c1d2e3f4a5b6c7d8e9f";
    readonly "LINK/USD": "8ac0c70fff57e9aefdf5edf44b51d62c2d433653cbb2cf5cc06bb115af04d221";
    readonly "ATOM/USD": "b00b60f88b03a6a625a8d1c048c3f66653edf217439cb6a1cbab0c1c5e8c52bd";
    readonly "LTC/USD": "6e3f3fa8253588df9326580180233eb791e03b443a3ba7a1d892e73874e19a54";
    readonly "UNI/USD": "78d185a741d07edb3412b09008b7c5cfb9bbbd7d568bf00ba737b456ba171501";
    readonly "NEAR/USD": "c415de8d2eba7db216527dff4b60e8f3a5311c740dadb233e13e12547e226750";
    readonly "TRX/USD": "67aed5a24fdad045475e7195c98a98aea119c763f272d4523f5bac93a4f33c2b";
    readonly "ARB/USD": "3fa4252848f9f0a1480be62745a4629d9eb1322aebab8a791e344b3b9c1adcf5";
    readonly "OP/USD": "385f64d993f7b77d8182ed5003d97c60aa3361f3cecfe711544d2d59165e9bdf";
    readonly "MNT/USD": "4e3037c822d852d79af3ac80e35eb420ee3b870dca49f9344a38ef4773fb0585";
    readonly "IMX/USD": "941320a8989414a6d2c757c8c6c52b3e7e0b7e4e4c5bb8a3c8e7a0f3e0f0f0f0";
    readonly "STRK/USD": "6a182399ff70ccf3e06024898942028204125a819e519a335ffa4579e66cd870";
    readonly "AAVE/USD": "2b9ab1e972a281585084148ba1389800799bd4be63b957507db1349314e47445";
    readonly "CRV/USD": "a19d04ac696c7a6616d291c7e5d1377cc8be437c327b75adb5dc1bad745fcae8";
    readonly "MKR/USD": "9375299e31c0deb9c6bc378e6329aab44cb48ec655552a70d4b9050346a30378";
    readonly "SNX/USD": "39d020f60982ed892abbcd4a06a276a9f9b7bfbce003204c110b6e488f502da3";
    readonly "COMP/USD": "4a8e42861cabc5ecb50996f92e7cfa2bce3fd0a2423b0c44c9b423fb2bd25478";
    readonly "LDO/USD": "c63e2a7f37a04e5e614c07238bedb25dcc38927e77a90a4b21a7a2e1d7f0d2e3";
    readonly "1INCH/USD": "63f341689d98a12ef60a5cff1d7f85c70a9e17bf1575f0e7c0b2512d48b1c8b3";
    readonly "SUSHI/USD": "26e4f737fde0263a9eea10ae63ac36dcedab2aaf629f1e31a28a28dd0e0d2b0c";
    readonly "YFI/USD": "425f4b198ab2504936886c1e93511bb6720fbcf2045a4f3c0723bb213846022f";
    readonly "BAL/USD": "07ad7b4a7662d19a6bc675f6b467172d2f3947fa653ca97555a9b20236406628";
    readonly "CAKE/USD": "2356af9529a1064d1d2a2e3e4ab6d6e6f6e6f6e6f6e6f6e6f6e6f6e6f6e6f6e6";
    readonly "GMX/USD": "b962539d0fcb272a494d65ea56f94851c2bcf8823935da05bd628916e2e9edbf";
    readonly "PENDLE/USD": "9a4df90b25497f66b1afb012467e316e801ca3d839456db028892fe8c70c8016";
    readonly "JOE/USD": "1e8a156c8a23c1e56f2d9d7f0e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e";
    readonly "USDC/USD": "eaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a";
    readonly "USDT/USD": "2b89b9dc8fdf9f34709a5b106b472f0f39bb6ca9ce04b0fd7f2e971688e2e53b";
    readonly "DAI/USD": "b0948a5e5313200c632b51bb5ca32f6de0d36e9950a942d19751e833f70dabfd";
    readonly "FRAX/USD": "c3d5d8d6d0c0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0";
    readonly "BUSD/USD": "5bc91f13e412c07599167bae86f07543f076a638962b8d6017ec19dab4a82814";
    readonly "TUSD/USD": "433faaa801ecda2c0bbfa8f4e2d85fd4c310e2c1e5f8f8e6e5f5f5f5f5f5f5f5";
    readonly "LUSD/USD": "d892ae586f4e0fbeee4d64f29ed6e89b1b3e2e2e2e2e2e2e2e2e2e2e2e2e2e2e";
    readonly "WETH/USD": "ff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace";
    readonly "WBTC/USD": "c9d8b075a5c69303365ae23633d4e085199bf5c520a3b90fed1322a0342ffc33";
    readonly "stETH/USD": "846ae1bdb6300b817cee5fdee2a6da192775030db5615b94a465f53bd40850b5";
    readonly "cbETH/USD": "15ecddd26d49e1a8f1de9376ebebc03916ede873447c1255d2d5891b92ce5717";
    readonly "rETH/USD": "a0255134973f4fdf2f8f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f";
    readonly "mETH/USD": "4c9c6f9f0cde13fced52dc1927c8c06a91b1a65ab77b9e1ec1c614963ce90dd4";
    readonly "wstETH/USD": "6df640f3b8963d8f8358f791f352b8364513f6ab1cca5ed3f1f7b5448980e784";
    readonly "SHIB/USD": "f0d57deca57b3da2fe63a493f4c25925fdfd8edf834b20f93e1f84dbd1504d4a";
    readonly "PEPE/USD": "d69731a2e74ac1ce884fc3890f7ee324b6deb66147055249568869ed700882e4";
    readonly "FLOKI/USD": "6b1381ce7e874dc5410b197ac8348162c0dd6c0d4c9cd6322c28a6f7f4d1a2d2";
    readonly "BONK/USD": "72b021217ca3fe68922a19aaf990109cb9d84e9ad004b4d2025ad6f529314419";
    readonly "WIF/USD": "4ca4beeca86f0d164160323817a4e42b10010a724c2217c6ee41b54cd4cc61fc";
    readonly "AXS/USD": "b0d8f5e3f3a7c0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0";
    readonly "SAND/USD": "f4040ec3e5b71c241a7e1a9a1e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e";
    readonly "MANA/USD": "2b15e4bded7f5e5d5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a";
    readonly "GALA/USD": "e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3";
    readonly "APE/USD": "15add95022ae13563a11992e727c91bdb6b55bc183d9d747436c80a483d8c864";
    readonly "ENJ/USD": "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a";
    readonly "FIL/USD": "150ac9b959aee0051e4091f0ef5216d941f590e1c5e7f91cf7635b5c11628c0e";
    readonly "GRT/USD": "4d1f8dae0d96236fb98e8f47571a70f41c8b8f2f6d6c0e0e0e0e0e0e0e0e0e0e";
    readonly "RNDR/USD": "ab7347771135fc733f8f38db462ba085ed3309955f42554a14fa13e855ac0e2f";
    readonly "INJ/USD": "7a5bc1d2b56ad029048cd63964b3ad2776eadf812edc1a43a31406cb54bff592";
    readonly "AR/USD": "8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c";
    readonly "THETA/USD": "4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a";
    readonly "PYTH/USD": "0bbf28e9a841a1cc788f6a361b17ca072d0ea3098a1e5df1c3922d06719579ff";
    readonly "FET/USD": "b49ee9d8ccf9b6e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0";
    readonly "OCEAN/USD": "2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d";
    readonly "TAO/USD": "410f41de235f2dbdf41f1a808c1e15f6a9e7d6a7b8c9d0e1f2a3b4c5d6e7f8a9";
    readonly "FTT/USD": "6c75e52531ec5fd3ef253f6062956a8508a2f03fa0a209fb7dbc0d0f3d6f6f6f";
    readonly "CRO/USD": "b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7";
    readonly "OKB/USD": "23d7315113f5b1d3ba7a83604c44b94d79f4fd69af77f804fc7f920a6dc65744";
    readonly "EUR/USD": "a995d00bb36a63cef7fd2c287dc105fc8f3d93779f062f09551b0af3e81ec30b";
    readonly "GBP/USD": "84c2dde9633d93d1bcad84e7dc41c9d56578b7ec52fabedc1f335d673df0a7c1";
    readonly "JPY/USD": "ef2c98c804ba503c6a707e38be4dfbb16683775f195b091252bf24693042fd52";
    readonly "AUD/USD": "67a6f93030f4217f2e8f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f";
    readonly "CAD/USD": "9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a";
    readonly "XAU/USD": "765d2ba906dbc32ca17cc11f5310a89e9ee1f6420508c63861f2f8ba4ee34bb2";
    readonly "XAG/USD": "f2fb02c32b055c805e7238d628e5e9dadef274376114eb1f012337cabe93871e";
    readonly "WTI/USD": "c9c8e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9";
    readonly "BRENT/USD": "d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8";
    readonly "AAPL/USD": "49f6b65cb1de6b10eaf75e7c03ca029c306d0357e91b5311b175084a5ad55688";
    readonly "NVDA/USD": "b1073854ed24cbc755dc527418f52b7d271f6cc967bbf8d8129112b18860a593";
    readonly "TSLA/USD": "16dad506d7db8da01c87581c87ca897a012a153557d4d578c3b9c9e1bc0632f1";
    readonly "GOOGL/USD": "b7e3904c08ddd9c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0";
    readonly "AMZN/USD": "c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6";
    readonly "MSFT/USD": "d0ca23c1cc005e004ccf1db5bf76aeb6a49218f43dac3d4b275e92de12ea4b77";
    readonly "META/USD": "a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4";
    readonly "COIN/USD": "9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b";
    readonly "SPY/USD": "19e09bb805456ada3979a7d1cbb4b6d63babc3a0f8e8a9b3c4d5e6f7a8b9c0d1";
    readonly "QQQ/USD": "2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e";
};
declare const PYTH_ABI: readonly [{
    readonly inputs: readonly [{
        readonly name: "id";
        readonly type: "bytes32";
    }];
    readonly name: "getPrice";
    readonly outputs: readonly [{
        readonly components: readonly [{
            readonly name: "price";
            readonly type: "int64";
        }, {
            readonly name: "conf";
            readonly type: "uint64";
        }, {
            readonly name: "expo";
            readonly type: "int32";
        }, {
            readonly name: "publishTime";
            readonly type: "uint256";
        }];
        readonly name: "";
        readonly type: "tuple";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "id";
        readonly type: "bytes32";
    }];
    readonly name: "getPriceNoOlderThan";
    readonly outputs: readonly [{
        readonly components: readonly [{
            readonly name: "price";
            readonly type: "int64";
        }, {
            readonly name: "conf";
            readonly type: "uint64";
        }, {
            readonly name: "expo";
            readonly type: "int32";
        }, {
            readonly name: "publishTime";
            readonly type: "uint256";
        }];
        readonly name: "";
        readonly type: "tuple";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "id";
        readonly type: "bytes32";
    }, {
        readonly name: "age";
        readonly type: "uint256";
    }];
    readonly name: "getPriceNoOlderThan";
    readonly outputs: readonly [{
        readonly components: readonly [{
            readonly name: "price";
            readonly type: "int64";
        }, {
            readonly name: "conf";
            readonly type: "uint64";
        }, {
            readonly name: "expo";
            readonly type: "int32";
        }, {
            readonly name: "publishTime";
            readonly type: "uint256";
        }];
        readonly name: "";
        readonly type: "tuple";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "id";
        readonly type: "bytes32";
    }];
    readonly name: "getPriceUnsafe";
    readonly outputs: readonly [{
        readonly components: readonly [{
            readonly name: "price";
            readonly type: "int64";
        }, {
            readonly name: "conf";
            readonly type: "uint64";
        }, {
            readonly name: "expo";
            readonly type: "int32";
        }, {
            readonly name: "publishTime";
            readonly type: "uint256";
        }];
        readonly name: "";
        readonly type: "tuple";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "id";
        readonly type: "bytes32";
    }];
    readonly name: "getEmaPrice";
    readonly outputs: readonly [{
        readonly components: readonly [{
            readonly name: "price";
            readonly type: "int64";
        }, {
            readonly name: "conf";
            readonly type: "uint64";
        }, {
            readonly name: "expo";
            readonly type: "int32";
        }, {
            readonly name: "publishTime";
            readonly type: "uint256";
        }];
        readonly name: "";
        readonly type: "tuple";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "updateData";
        readonly type: "bytes[]";
    }];
    readonly name: "updatePriceFeeds";
    readonly outputs: readonly [];
    readonly stateMutability: "payable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "updateData";
        readonly type: "bytes[]";
    }];
    readonly name: "getUpdateFee";
    readonly outputs: readonly [{
        readonly name: "feeAmount";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "id";
        readonly type: "bytes32";
    }];
    readonly name: "priceFeedExists";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "updateData";
        readonly type: "bytes[]";
    }, {
        readonly name: "priceIds";
        readonly type: "bytes32[]";
    }, {
        readonly name: "minPublishTime";
        readonly type: "uint64";
    }, {
        readonly name: "maxPublishTime";
        readonly type: "uint64";
    }];
    readonly name: "parsePriceFeedUpdates";
    readonly outputs: readonly [{
        readonly components: readonly [{
            readonly name: "id";
            readonly type: "bytes32";
        }, {
            readonly components: readonly [{
                readonly name: "price";
                readonly type: "int64";
            }, {
                readonly name: "conf";
                readonly type: "uint64";
            }, {
                readonly name: "expo";
                readonly type: "int32";
            }, {
                readonly name: "publishTime";
                readonly type: "uint256";
            }];
            readonly name: "price";
            readonly type: "tuple";
        }, {
            readonly components: readonly [{
                readonly name: "price";
                readonly type: "int64";
            }, {
                readonly name: "conf";
                readonly type: "uint64";
            }, {
                readonly name: "expo";
                readonly type: "int32";
            }, {
                readonly name: "publishTime";
                readonly type: "uint256";
            }];
            readonly name: "emaPrice";
            readonly type: "tuple";
        }];
        readonly name: "";
        readonly type: "tuple[]";
    }];
    readonly stateMutability: "payable";
    readonly type: "function";
}];
interface PythPriceData {
    price: bigint;
    conf: bigint;
    expo: number;
    publishTime: bigint;
}
interface PythPriceResponse {
    priceFeedId: string;
    pair: string;
    price: string;
    confidence: string;
    exponent: number;
    publishTime: number;
    formattedPrice: string;
}
interface PythTokenPriceResponse {
    tokenAddress: string;
    tokenSymbol: string;
    pair: string;
    priceFeedId: string;
    priceUsd: string;
    confidence: string;
    exponent: number;
    publishTime: number;
    lastUpdated: string;
}
declare const TOKEN_ADDRESS_TO_PRICE_FEED: Record<string, {
    pair: string;
    feedId: string;
}>;
declare function isTokenAddress(input: string): boolean;
declare function resolvePriceFeedInput(input: string): {
    pair: string;
    feedId: string;
} | null;

declare const index$b_HERMES_ENDPOINT: typeof HERMES_ENDPOINT;
declare const index$b_PYTH_ABI: typeof PYTH_ABI;
declare const index$b_PYTH_CONTRACT: typeof PYTH_CONTRACT;
declare const index$b_PYTH_PRICE_FEED_IDS: typeof PYTH_PRICE_FEED_IDS;
type index$b_PythPriceData = PythPriceData;
type index$b_PythPriceResponse = PythPriceResponse;
type index$b_PythTokenPriceResponse = PythTokenPriceResponse;
declare const index$b_TOKEN_ADDRESS_TO_PRICE_FEED: typeof TOKEN_ADDRESS_TO_PRICE_FEED;
declare const index$b_isTokenAddress: typeof isTokenAddress;
declare const index$b_resolvePriceFeedInput: typeof resolvePriceFeedInput;
declare namespace index$b {
  export { index$b_HERMES_ENDPOINT as HERMES_ENDPOINT, index$b_PYTH_ABI as PYTH_ABI, index$b_PYTH_CONTRACT as PYTH_CONTRACT, index$b_PYTH_PRICE_FEED_IDS as PYTH_PRICE_FEED_IDS, type index$b_PythPriceData as PythPriceData, type index$b_PythPriceResponse as PythPriceResponse, type index$b_PythTokenPriceResponse as PythTokenPriceResponse, index$b_TOKEN_ADDRESS_TO_PRICE_FEED as TOKEN_ADDRESS_TO_PRICE_FEED, index$b_isTokenAddress as isTokenAddress, index$b_resolvePriceFeedInput as resolvePriceFeedInput };
}

interface OpenPositionResult$1 {
    positionId: bigint;
    txHash: Hex;
}
/**
 * Open a short position on PikePerps
 * @param agent - MNTAgentKit instance
 * @param tokenAddress - Token to trade (meme token address)
 * @param margin - Margin amount in wei (as string)
 * @param leverage - Leverage multiplier (1-100)
 * @returns Position ID and transaction hash
 */
declare function pikeperpsOpenShort(agent: MNTAgentKit, tokenAddress: Address, margin: string, leverage?: number): Promise<OpenPositionResult$1>;

interface OpenPositionResult {
    positionId: bigint;
    txHash: Hex;
}
/**
 * Open a long position on PikePerps
 * @param agent - MNTAgentKit instance
 * @param tokenAddress - Token to trade (meme token address)
 * @param margin - Margin amount in wei (as string)
 * @param leverage - Leverage multiplier (1-100)
 * @returns Position ID and transaction hash
 */
declare function pikeperpsOpenLong(agent: MNTAgentKit, tokenAddress: Address, margin: string, leverage?: number): Promise<OpenPositionResult>;

interface SquidRoute {
    route: {
        estimate: {
            fromAmount: string;
            toAmount: string;
            toAmountMin: string;
            route: {
                actionType: string;
                chainType: string;
                data: {
                    tokenIn: string;
                    tokenOut: string;
                    amountIn: string;
                    amountOut: string;
                    path: string[];
                };
            }[];
            estimatedRouteDuration: number;
            aggregatePriceImpact: string;
            feeCosts: {
                name: string;
                description: string;
                percentage: string;
                amount: string;
                amountUSD: string;
            }[];
            gasCosts: {
                type: string;
                amount: string;
                amountUSD: string;
                gasPrice: string;
                maxFeePerGas: string;
                maxPriorityFeePerGas: string;
                estimate: string;
            }[];
        };
        transactionRequest: {
            routeType: string;
            targetAddress: string;
            data: string;
            value: string;
            gasLimit: string;
            gasPrice: string;
            maxFeePerGas: string;
            maxPriorityFeePerGas: string;
        };
    };
}

declare const sendTransaction: (agent: MNTAgentKit, to: Address, amount: string, tokenAddress?: Address) => Promise<viem.TransactionReceipt<bigint, number, "success" | "reverted", viem.TransactionType> | {
    transactionHash: `0x${string}`;
    status: "success";
    blockNumber: bigint;
    blockHash: `0x${string}`;
    from: `0x${string}`;
    to: `0x${string}`;
    value: bigint;
    gasUsed: bigint;
    effectiveGasPrice: bigint;
    cumulativeGasUsed: bigint;
    logs: never[];
    logsBloom: `0x${string}`;
    type: "eip1559";
}>;

/**
 * Check allowance and get approve tx data if needed
 * @param agent - MNTAgentKit instance
 * @param tokenAddress - Token to approve
 * @param amount - Amount to approve
 * @returns Allowance status and tx data
 */
declare function approveToken(agent: MNTAgentKit, tokenAddress: string, amount: string): Promise<{
    allowanceExists: boolean;
    data: any;
}>;

interface OKXToken {
    decimals: string;
    tokenContractAddress: string;
    tokenLogoUrl: string;
    tokenName: string;
    tokenSymbol: string;
}

/**
 * Execute token swap
 * @param fromTokenAddress - Source token address
 * @param toTokenAddress - Destination token address
 * @param amount - Amount to swap
 * @param slippagePercent - Maximum slippagePercent
 * @returns Transaction hash
 */
declare function executeSwap(agent: MNTAgentKit, fromTokenAddress: string, toTokenAddress: string, amount: string, slippagePercent: string): Promise<{
    data: any;
}>;

interface OpenOceanQuote {
    inToken: {
        address: string;
        decimals: number;
        symbol: string;
        name: string;
    };
    outToken: {
        address: string;
        decimals: number;
        symbol: string;
        name: string;
    };
    inAmount: string;
    outAmount: string;
    estimatedGas: string;
}

interface OpenOceanToken {
    id: number;
    code: string;
    name: string;
    address: string;
    decimals: number;
    symbol: string;
    icon: string;
    chain: string;
    usd: string;
}

/**
 * Get swap quote from OpenOcean
 * @param agent - MNTAgentKit instance
 * @param fromToken - Source token address
 * @param toToken - Destination token address
 * @param amount - Amount to swap (human-readable, e.g., "1" for 1 token)
 * @returns Quote data including estimated output amount
 */
declare function getOpenOceanQuote(agent: MNTAgentKit, fromToken: string, toToken: string, amount: string): Promise<OpenOceanQuote>;

/**
 * Execute token swap on OpenOcean
 * @param agent - MNTAgentKit instance
 * @param fromToken - Source token address
 * @param toToken - Destination token address
 * @param amount - Amount to swap (human-readable, e.g., "1" for 1 token)
 * @param slippage - Slippage percentage (e.g., "1" for 1%)
 * @returns Transaction hash
 */
declare function swapOnOpenOcean(agent: MNTAgentKit, fromToken: string, toToken: string, amount: string, slippage?: string): Promise<{
    txHash: string;
    outAmount: string;
}>;

declare const SWAP_ROUTER_ADDRESS = "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45";
declare const QUOTER_V2_ADDRESS = "0x61fFE014bA17989E743c5F6cB21bF9697530B21e";
declare const FACTORY_ADDRESS = "0x1F98431c8aD98523631AE4a59f267346ea31F984";
declare const WMNT_ADDRESS$1 = "0x78c1b0C915c4FAA5FffA6CAbf0219DA63d7f4cb8";
declare const NATIVE_TOKEN_ADDRESS$2 = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
declare const FEE_TIERS$1: {
    readonly LOWEST: 100;
    readonly LOW: 500;
    readonly MEDIUM: 3000;
    readonly HIGH: 10000;
};
declare const DEFAULT_POOL_FEE: 3000;

declare const index$a_DEFAULT_POOL_FEE: typeof DEFAULT_POOL_FEE;
declare const index$a_FACTORY_ADDRESS: typeof FACTORY_ADDRESS;
declare const index$a_QUOTER_V2_ADDRESS: typeof QUOTER_V2_ADDRESS;
declare const index$a_SWAP_ROUTER_ADDRESS: typeof SWAP_ROUTER_ADDRESS;
declare namespace index$a {
  export { index$a_DEFAULT_POOL_FEE as DEFAULT_POOL_FEE, index$a_FACTORY_ADDRESS as FACTORY_ADDRESS, FEE_TIERS$1 as FEE_TIERS, NATIVE_TOKEN_ADDRESS$2 as NATIVE_TOKEN_ADDRESS, index$a_QUOTER_V2_ADDRESS as QUOTER_V2_ADDRESS, index$a_SWAP_ROUTER_ADDRESS as SWAP_ROUTER_ADDRESS, WMNT_ADDRESS$1 as WMNT_ADDRESS };
}

interface UniswapQuoteResult {
    amountOut: bigint;
    sqrtPriceX96After: bigint;
    gasEstimate: bigint;
}

/**
 * Get swap quote from Uniswap V3
 * @param agent - MNTAgentKit instance
 * @param fromToken - Source token address
 * @param toToken - Destination token address
 * @param amount - Amount to swap (in smallest units)
 * @param fee - Pool fee tier (default: 3000 = 0.3%)
 * @returns Quote with expected output amount
 */
declare function getUniswapQuote(agent: MNTAgentKit, fromToken: string, toToken: string, amount: string, fee?: number): Promise<UniswapQuoteResult>;

/**
 * Execute token swap on Uniswap V3
 * @param agent - MNTAgentKit instance
 * @param fromToken - Source token address
 * @param toToken - Destination token address
 * @param amount - Amount to swap (in smallest units)
 * @param slippage - Slippage percentage (e.g., "0.5" for 0.5%)
 * @param fee - Pool fee tier (default: 3000 = 0.3%)
 * @returns Transaction hash and output amount
 */
declare function swapOnUniswap(agent: MNTAgentKit, fromToken: string, toToken: string, amount: string, slippage?: string, fee?: number): Promise<{
    txHash: string;
    amountOut: string;
}>;

/**
 * Execute cross-chain swap via Squid Router
 * @param agent - MNTAgentKit instance
 * @param fromToken - Source token address
 * @param toToken - Destination token address
 * @param fromChain - Source chain ID (LayerZero chain ID)
 * @param toChain - Destination chain ID (LayerZero chain ID)
 * @param amount - Amount to swap (in smallest units)
 * @param slippage - Slippage tolerance percentage (default: 1%)
 * @returns Transaction hash
 */
declare function crossChainSwapViaSquid(agent: MNTAgentKit, fromToken: Address, toToken: Address, fromChain: number, toChain: number, amount: string, slippage?: number): Promise<Hex>;
/**
 * Get cross-chain swap route from Squid Router
 * @param agent - MNTAgentKit instance
 * @param fromToken - Source token address
 * @param toToken - Destination token address
 * @param fromChain - Source chain ID (LayerZero chain ID)
 * @param toChain - Destination chain ID (LayerZero chain ID)
 * @param amount - Amount to swap (in smallest units)
 * @param slippage - Slippage tolerance percentage (default: 1%)
 * @returns Route data including estimated output and fees
 */
declare function getSquidRoute(agent: MNTAgentKit, fromToken: Address, toToken: Address, fromChain: number, toChain: number, amount: string, slippage?: number): Promise<{
    route: {
        estimate: {
            toAmount: string;
        };
        transactionRequest: {
            targetAddress: string;
            data: string;
            value: string;
            gasLimit: string;
        };
    };
    demo: boolean;
    message: string;
} | SquidRoute>;

/**
 * Supply (deposit) tokens to Lendle Protocol
 * @param agent - MNTAgentKit instance
 * @param tokenAddress - Token address to supply
 * @param amount - Amount to supply (in smallest units)
 * @returns Transaction hash
 */
declare function lendleSupply(agent: MNTAgentKit, tokenAddress: Address, amount: string): Promise<Hex>;

/**
 * Withdraw tokens from Lendle Protocol
 * @param agent - MNTAgentKit instance
 * @param tokenAddress - Token address to withdraw
 * @param amount - Amount to withdraw (in smallest units, use max uint256 for max)
 * @param to - Address to receive withdrawn tokens (optional, defaults to agent address)
 * @returns Transaction hash
 */
declare function lendleWithdraw(agent: MNTAgentKit, tokenAddress: Address, amount: string, to?: Address): Promise<Hex>;

/**
 * Borrow tokens from Lendle Protocol
 * @param agent - MNTAgentKit instance
 * @param tokenAddress - Token address to borrow
 * @param amount - Amount to borrow (in smallest units)
 * @param interestRateMode - Interest rate mode (1 = stable, 2 = variable)
 * @param onBehalfOf - Address to receive borrowed tokens (optional, defaults to agent address)
 * @returns Transaction hash
 */
declare function lendleBorrow(agent: MNTAgentKit, tokenAddress: Address, amount: string, interestRateMode?: 1 | 2, onBehalfOf?: Address): Promise<Hex>;

/**
 * Repay borrowed tokens to Lendle Protocol
 * @param agent - MNTAgentKit instance
 * @param tokenAddress - Token address to repay
 * @param amount - Amount to repay (in smallest units, use max uint256 for full repayment)
 * @param rateMode - Interest rate mode (1 = stable, 2 = variable)
 * @param onBehalfOf - Address whose debt to repay (optional, defaults to agent address)
 * @returns Transaction hash
 */
declare function lendleRepay(agent: MNTAgentKit, tokenAddress: Address, amount: string, rateMode?: 1 | 2, onBehalfOf?: Address): Promise<Hex>;

interface LendlePosition {
    asset: Address;
    symbol: string;
    supplied: bigint;
    stableDebt: bigint;
    variableDebt: bigint;
    totalDebt: bigint;
    liquidityRate: bigint;
    stableBorrowRate: bigint;
    usageAsCollateralEnabled: boolean;
}
interface LendlePositionsResult {
    positions: LendlePosition[];
    totalSupplied: bigint;
    totalDebt: bigint;
}
/**
 * Get all Lendle positions for a user
 * Returns per-token supply and borrow amounts
 * @param agent - MNTAgentKit instance
 * @param userAddress - User wallet address (optional, defaults to agent account)
 * @returns Array of positions with supply/borrow amounts per asset
 */
declare function lendleGetPositions(agent: MNTAgentKit, userAddress?: Address): Promise<LendlePositionsResult>;

/**
 * Swap tokens on Agni Finance DEX
 * @param agent - MNTAgentKit instance
 * @param tokenIn - Input token address
 * @param tokenOut - Output token address
 * @param amountIn - Amount to swap (in smallest units)
 * @param slippagePercent - Slippage tolerance (default: 0.5%)
 * @param feeTier - Pool fee tier (default: MEDIUM = 0.3%)
 * @returns Transaction hash
 */
declare function agniSwap(agent: MNTAgentKit, tokenIn: Address, tokenOut: Address, amountIn: string, slippagePercent?: number, feeTier?: number): Promise<Hex>;

/**
 * Swap tokens on Merchant Moe DEX (LB Router)
 * Supports native MNT -> Token and Token -> Token swaps
 * @param agent - MNTAgentKit instance
 * @param tokenIn - Input token address (use 0xEeee...EEeE for native MNT)
 * @param tokenOut - Output token address
 * @param amountIn - Amount to swap (in smallest units)
 * @param slippagePercent - Slippage tolerance (default: 0.5%)
 * @param binStep - Bin step for the pair (optional, will auto-detect)
 * @returns Transaction hash
 */
declare function merchantMoeSwap(agent: MNTAgentKit, tokenIn: Address, tokenOut: Address, amountIn: string, slippagePercent?: number, binStep?: number): Promise<Hex>;

declare const METH_TOKEN: {
    readonly mainnet: "0xcDA86A272531e8640cD7F1a92c01839911B90bb0";
    readonly testnet: "0x0000000000000000000000000000000000000000";
};
declare const WETH_TOKEN: {
    readonly mainnet: "0xdEAddEaDdeadDEadDEADDEAddEADDEAddead1111";
    readonly testnet: "0xdEAddEaDdeadDEadDEADDEAddEADDEAddead1111";
};
declare const WMNT_TOKEN: {
    readonly mainnet: "0x78c1b0C915c4FAA5FffA6CAbf0219DA63d7f4cb8";
    readonly testnet: "0x78c1b0C915c4FAA5FffA6CAbf0219DA63d7f4cb8";
};
declare const NATIVE_MNT_ADDRESS: "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
declare const METH_ABI: readonly [{
    readonly inputs: readonly [{
        readonly name: "account";
        readonly type: "address";
    }];
    readonly name: "balanceOf";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "totalSupply";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "decimals";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "uint8";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "symbol";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "spender";
        readonly type: "address";
    }, {
        readonly name: "amount";
        readonly type: "uint256";
    }];
    readonly name: "approve";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly name: "spender";
        readonly type: "address";
    }];
    readonly name: "allowance";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}];

declare const index$9_METH_ABI: typeof METH_ABI;
declare const index$9_METH_TOKEN: typeof METH_TOKEN;
declare const index$9_NATIVE_MNT_ADDRESS: typeof NATIVE_MNT_ADDRESS;
declare const index$9_WETH_TOKEN: typeof WETH_TOKEN;
declare const index$9_WMNT_TOKEN: typeof WMNT_TOKEN;
declare namespace index$9 {
  export { index$9_METH_ABI as METH_ABI, index$9_METH_TOKEN as METH_TOKEN, index$9_NATIVE_MNT_ADDRESS as NATIVE_MNT_ADDRESS, index$9_WETH_TOKEN as WETH_TOKEN, index$9_WMNT_TOKEN as WMNT_TOKEN };
}

interface MethPosition {
    methBalance: bigint;
    wethBalance: bigint;
    wmntBalance: bigint;
    methTokenAddress: Address;
    wethTokenAddress: Address;
    wmntTokenAddress: Address;
}
/**
 * Get mETH position for a user
 * Returns mETH balance, WETH balance (for swaps), and WMNT balance
 * @param agent - MNTAgentKit instance
 * @param userAddress - User wallet address (optional, defaults to agent account)
 * @returns mETH position with balances
 */
declare function methGetPosition(agent: MNTAgentKit, userAddress?: Address): Promise<MethPosition>;

/**
 * Swap WETH to mETH using DEX aggregator
 * This is the L2 way to acquire mETH - swap via DEX
 * @param agent - MNTAgentKit instance
 * @param amount - Amount of WETH to swap (in wei as string)
 * @param slippage - Slippage tolerance percentage (default 0.5%)
 * @returns Transaction hash
 */
declare function swapToMeth(agent: MNTAgentKit, amount: string, slippage?: number): Promise<Hex>;

/**
 * Swap mETH to WETH using DEX aggregator
 * This is the L2 way to exit mETH position - swap via DEX
 * @param agent - MNTAgentKit instance
 * @param amount - Amount of mETH to swap (in wei as string)
 * @param slippage - Slippage tolerance percentage (default 0.5%)
 * @returns Transaction hash
 */
declare function swapFromMeth(agent: MNTAgentKit, amount: string, slippage?: number): Promise<Hex>;

/**
 * Close an existing position on PikePerps
 * @param agent - MNTAgentKit instance
 * @param positionId - Position ID to close
 * @returns Transaction hash
 */
declare function pikeperpsClosePosition(agent: MNTAgentKit, positionId: bigint): Promise<Hex>;

interface PikePerpsPosition {
    positionId: bigint;
    token: Address;
    isLong: boolean;
    size: bigint;
    margin: bigint;
    leverage: number;
    entryPrice: bigint;
    entryTime: bigint;
    currentPrice: bigint;
    pnl: bigint;
    isProfit: boolean;
    liquidationPrice: bigint;
    isOpen: boolean;
}
/**
 * Get all positions for a user on PikePerps
 * Returns detailed position data including PnL and liquidation prices
 * @param agent - MNTAgentKit instance
 * @param userAddress - User wallet address (optional, defaults to agent account)
 * @returns Array of positions with PnL and liquidation data
 */
declare function pikeperpsGetPositions(agent: MNTAgentKit, userAddress?: Address): Promise<PikePerpsPosition[]>;

interface PikePerpsTrade {
    positionId: bigint;
    trader: Address;
    token: Address;
    isLong: boolean;
    size: bigint;
    margin: bigint;
    leverage: bigint;
    entryPrice: bigint;
    timestamp: number;
    txHash: Hex;
    blockNumber: bigint;
}
interface PikePerpsMarketData {
    token: Address;
    currentPrice: bigint;
    hasPrice: boolean;
    isListed: boolean;
    curveProgress: bigint;
    recentTrades: PikePerpsTrade[];
}
/**
 * Get market data for a token on PikePerps
 * Returns current price and recent trades
 * @param agent - MNTAgentKit instance
 * @param tokenAddress - Token address to get market data for
 * @param limit - Maximum number of recent trades to return (default 20)
 * @returns Market data with price and recent trades
 */
declare function pikeperpsGetMarketData(agent: MNTAgentKit, tokenAddress: Address, limit?: number): Promise<PikePerpsMarketData>;

/**
 * Get price data from Pyth Network for a specific price feed
 * @param agent - MNTAgentKit instance
 * @param input - Token address, price feed ID (hex string), or pair name like "ETH/USD"
 * @returns Price data with formatted price
 */
declare function pythGetPrice(agent: MNTAgentKit, input: string): Promise<PythPriceResponse>;
/**
 * Get EMA (Exponential Moving Average) price from Pyth
 * @param agent - MNTAgentKit instance
 * @param input - Token address, price feed ID, or pair name
 * @returns EMA price data
 */
declare function pythGetEmaPrice(agent: MNTAgentKit, input: string): Promise<PythPriceResponse>;
/**
 * Get price for a token by its contract address
 * @param agent - MNTAgentKit instance
 * @param tokenAddress - Token contract address on Mantle (e.g., "0x09Bc4E0D10C81b3a3766c49F0f98a8aaa7adA8D2" for USDC)
 * @returns Token price details including address, symbol, and USD price
 * @example
 * const price = await pythGetTokenPrice(agent, "0x09Bc4E0D10C81b3a3766c49F0f98a8aaa7adA8D2");
 * // Returns: { tokenAddress: "0x09Bc...", tokenSymbol: "USDC", priceUsd: "1.00", ... }
 */
declare function pythGetTokenPrice(agent: MNTAgentKit, tokenAddress: string): Promise<PythTokenPriceResponse>;

/**
 * Get multiple prices from Pyth in a single call
 * @param agent - MNTAgentKit instance
 * @param inputs - Array of token addresses, pair names, or price feed IDs
 * @returns Array of price responses
 */
declare function pythGetMultiplePrices(agent: MNTAgentKit, inputs: string[]): Promise<PythPriceResponse[]>;
/**
 * Get all supported Pyth price feed IDs
 * @returns Object mapping pair names to price feed IDs
 */
declare function pythGetSupportedPriceFeeds(): Record<string, string>;
/**
 * Get all supported token addresses that can be used for price lookups
 * @returns Object mapping token addresses to their pair names
 */
declare function pythGetSupportedTokenAddresses(): Record<string, string>;
/**
 * Check if a price feed exists on Pyth
 * @param agent - MNTAgentKit instance
 * @param input - Token address, price feed ID, or pair name
 * @returns Boolean indicating if feed exists
 */
declare function pythPriceFeedExists(agent: MNTAgentKit, input: string): Promise<boolean>;

declare const ERC20_ABI: readonly [{
    readonly inputs: readonly [];
    readonly name: "name";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "symbol";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "decimals";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "uint8";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "totalSupply";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "account";
        readonly type: "address";
    }];
    readonly name: "balanceOf";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly name: "amount";
        readonly type: "uint256";
    }];
    readonly name: "transfer";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}];
type TokenType = "standard" | "rwa";
interface TokenConfig {
    name: string;
    symbol: string;
    supply: string;
    decimals?: number;
    tokenType?: TokenType;
    assetType?: string;
    assetId?: string;
}
interface TokenDeploymentResult {
    tokenAddress: string;
    txHash: string;
    name: string;
    symbol: string;
    decimals: number;
    totalSupply: string;
    mintedTo: string;
    tokenType: TokenType;
    assetType?: string;
    assetId?: string;
}
interface TokenInfo {
    address: string;
    name: string;
    symbol: string;
    decimals: number;
    totalSupply: string;
    balance?: string;
}

declare const index$8_ERC20_ABI: typeof ERC20_ABI;
type index$8_TokenConfig = TokenConfig;
type index$8_TokenDeploymentResult = TokenDeploymentResult;
type index$8_TokenInfo = TokenInfo;
type index$8_TokenType = TokenType;
declare namespace index$8 {
  export { index$8_ERC20_ABI as ERC20_ABI, type index$8_TokenConfig as TokenConfig, type index$8_TokenDeploymentResult as TokenDeploymentResult, type index$8_TokenInfo as TokenInfo, type index$8_TokenType as TokenType };
}

/**
 * Deploy a new token (ERC20 or RWA) - mints supply to caller's address
 * @param agent - MNTAgentKit instance
 * @param name - Token name
 * @param symbol - Token symbol
 * @param supply - Total supply (human readable, e.g., "1000000")
 * @param tokenType - "standard" or "rwa"
 * @param assetType - For RWA: type of underlying asset
 * @param assetId - For RWA: external asset identifier
 */
declare function deployToken(agent: MNTAgentKit, name: string, symbol: string, supply: string, tokenType?: TokenType, assetType?: string, assetId?: string): Promise<TokenDeploymentResult>;
/**
 * Deploy a standard ERC20 token
 */
declare function deployStandardToken(agent: MNTAgentKit, name: string, symbol: string, supply: string): Promise<TokenDeploymentResult>;
/**
 * Deploy an RWA (Real World Asset) token
 * @param agent - MNTAgentKit instance
 * @param name - Token name (e.g., "Manhattan Property Token")
 * @param symbol - Token symbol (e.g., "MPT")
 * @param supply - Total supply representing fractional ownership
 * @param assetType - Asset category (e.g., "Real Estate", "Commodities", "Securities", "Art")
 * @param assetId - External reference ID for the underlying asset
 */
declare function deployRWAToken(agent: MNTAgentKit, name: string, symbol: string, supply: string, assetType: string, assetId?: string): Promise<TokenDeploymentResult>;

/**
 * Get token information
 */
declare function getTokenInfo(agent: MNTAgentKit, tokenAddress: Address, holder?: Address): Promise<TokenInfo>;
/**
 * Get token balance
 */
declare function getTokenBalance(agent: MNTAgentKit, tokenAddress: Address, holder?: Address): Promise<string>;

/**
 * Transfer tokens
 */
declare function transferToken(agent: MNTAgentKit, tokenAddress: Address, to: Address, amount: string): Promise<Hex>;

declare const ERC721_ABI: readonly [{
    readonly inputs: readonly [{
        readonly name: "name";
        readonly type: "string";
    }, {
        readonly name: "symbol";
        readonly type: "string";
    }, {
        readonly name: "baseURI";
        readonly type: "string";
    }, {
        readonly name: "maxSupply";
        readonly type: "uint256";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "constructor";
}, {
    readonly inputs: readonly [];
    readonly name: "name";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "symbol";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "totalSupply";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "tokenURI";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "ownerOf";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "owner";
        readonly type: "address";
    }];
    readonly name: "balanceOf";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "getApproved";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly name: "operator";
        readonly type: "address";
    }];
    readonly name: "isApprovedForAll";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "to";
        readonly type: "address";
    }];
    readonly name: "mint";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly name: "quantity";
        readonly type: "uint256";
    }];
    readonly name: "batchMint";
    readonly outputs: readonly [{
        readonly name: "startTokenId";
        readonly type: "uint256";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "approve";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly name: "approved";
        readonly type: "bool";
    }];
    readonly name: "setApprovalForAll";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "transferFrom";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "safeTransferFrom";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly name: "tokenId";
        readonly type: "uint256";
    }, {
        readonly name: "data";
        readonly type: "bytes";
    }];
    readonly name: "safeTransferFrom";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "Transfer";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly name: "approved";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "Approval";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly name: "approved";
        readonly type: "bool";
    }];
    readonly name: "ApprovalForAll";
    readonly type: "event";
}];
interface NFTCollectionConfig {
    name: string;
    symbol: string;
    baseURI: string;
    maxSupply?: number;
    description?: string;
}
interface NFTCollectionDeploymentResult {
    collectionAddress: string;
    txHash: string;
    name: string;
    symbol: string;
    baseURI: string;
    maxSupply: number;
    deployer: string;
}
interface NFTMintResult {
    txHash: string;
    tokenId: string;
    collectionAddress: string;
    to: string;
}
interface NFTCollectionInfo {
    address: string;
    name: string;
    symbol: string;
    totalSupply: string;
    balanceOf?: string;
}
interface NFTTokenInfo {
    collectionAddress: string;
    tokenId: string;
    owner: string;
    tokenURI: string;
}

declare const index$7_ERC721_ABI: typeof ERC721_ABI;
type index$7_NFTCollectionConfig = NFTCollectionConfig;
type index$7_NFTCollectionDeploymentResult = NFTCollectionDeploymentResult;
type index$7_NFTCollectionInfo = NFTCollectionInfo;
type index$7_NFTMintResult = NFTMintResult;
type index$7_NFTTokenInfo = NFTTokenInfo;
declare namespace index$7 {
  export { index$7_ERC721_ABI as ERC721_ABI, type index$7_NFTCollectionConfig as NFTCollectionConfig, type index$7_NFTCollectionDeploymentResult as NFTCollectionDeploymentResult, type index$7_NFTCollectionInfo as NFTCollectionInfo, type index$7_NFTMintResult as NFTMintResult, type index$7_NFTTokenInfo as NFTTokenInfo };
}

/**
 * Deploy a new ERC721 NFT collection on Mantle Network
 * @param agent - MNTAgentKit instance
 * @param config - NFT collection configuration
 * @returns Collection deployment result with contract address
 */
declare function deployNFTCollection(agent: MNTAgentKit, config: NFTCollectionConfig): Promise<NFTCollectionDeploymentResult>;
/**
 * Deploy an NFT collection with preset configurations
 * @param agent - MNTAgentKit instance
 * @param preset - Preset type: "pfp" (10000), "art" (1000), "membership" (100)
 * @param name - Collection name
 * @param symbol - Collection symbol
 * @param baseURI - Base URI for metadata
 * @returns Collection deployment result
 */
declare function deployNFTCollectionWithPreset(agent: MNTAgentKit, preset: "pfp" | "art" | "membership" | "unlimited", name: string, symbol: string, baseURI: string): Promise<NFTCollectionDeploymentResult>;

/**
 * Mint a single NFT from a collection
 * @param agent - MNTAgentKit instance
 * @param collectionAddress - NFT collection contract address
 * @param to - Recipient address (defaults to agent address)
 * @returns Mint result with token ID
 */
declare function mintNFT(agent: MNTAgentKit, collectionAddress: Address, to?: Address): Promise<NFTMintResult>;
/**
 * Batch mint multiple NFTs from a collection
 * @param agent - MNTAgentKit instance
 * @param collectionAddress - NFT collection contract address
 * @param to - Recipient address
 * @param quantity - Number of NFTs to mint
 * @returns Mint result with starting token ID
 */
declare function batchMintNFT(agent: MNTAgentKit, collectionAddress: Address, to: Address, quantity: number): Promise<{
    txHash: Hex;
    startTokenId: string;
    quantity: number;
}>;

/**
 * Get information about an NFT collection
 * @param agent - MNTAgentKit instance
 * @param collectionAddress - NFT collection contract address
 * @param holderAddress - Optional address to get balance for
 * @returns Collection information
 */
declare function getNFTCollectionInfo(agent: MNTAgentKit, collectionAddress: Address, holderAddress?: Address): Promise<NFTCollectionInfo>;
/**
 * Get information about a specific NFT token
 * @param agent - MNTAgentKit instance
 * @param collectionAddress - NFT collection contract address
 * @param tokenId - Token ID
 * @returns Token information
 */
declare function getNFTTokenInfo(agent: MNTAgentKit, collectionAddress: Address, tokenId: string): Promise<NFTTokenInfo>;
/**
 * Get NFT balance for an address
 * @param agent - MNTAgentKit instance
 * @param collectionAddress - NFT collection contract address
 * @param holderAddress - Address to check balance for (defaults to agent address)
 * @returns Balance as string
 */
declare function getNFTBalance(agent: MNTAgentKit, collectionAddress: Address, holderAddress?: Address): Promise<string>;
/**
 * Check if an address owns a specific NFT
 * @param agent - MNTAgentKit instance
 * @param collectionAddress - NFT collection contract address
 * @param tokenId - Token ID to check
 * @param ownerAddress - Address to verify ownership
 * @returns Boolean indicating ownership
 */
declare function isNFTOwner(agent: MNTAgentKit, collectionAddress: Address, tokenId: string, ownerAddress?: Address): Promise<boolean>;

/**
 * Transfer an NFT to another address
 * @param agent - MNTAgentKit instance
 * @param collectionAddress - NFT collection contract address
 * @param to - Recipient address
 * @param tokenId - Token ID to transfer
 * @returns Transaction hash
 */
declare function transferNFT(agent: MNTAgentKit, collectionAddress: Address, to: Address, tokenId: string): Promise<Hex>;
/**
 * Safe transfer an NFT (checks if recipient can receive)
 * @param agent - MNTAgentKit instance
 * @param collectionAddress - NFT collection contract address
 * @param to - Recipient address
 * @param tokenId - Token ID to transfer
 * @returns Transaction hash
 */
declare function safeTransferNFT(agent: MNTAgentKit, collectionAddress: Address, to: Address, tokenId: string): Promise<Hex>;
/**
 * Approve an address to transfer a specific NFT
 * @param agent - MNTAgentKit instance
 * @param collectionAddress - NFT collection contract address
 * @param approved - Address to approve
 * @param tokenId - Token ID to approve
 * @returns Transaction hash
 */
declare function approveNFT(agent: MNTAgentKit, collectionAddress: Address, approved: Address, tokenId: string): Promise<Hex>;
/**
 * Set approval for all NFTs in a collection
 * @param agent - MNTAgentKit instance
 * @param collectionAddress - NFT collection contract address
 * @param operator - Operator address
 * @param approved - Whether to approve or revoke
 * @returns Transaction hash
 */
declare function setApprovalForAllNFT(agent: MNTAgentKit, collectionAddress: Address, operator: Address, approved: boolean): Promise<Hex>;

/**
 * Platform Configuration & Validation
 *
 * Validates APP_ID with Mantle platform API
 */
/** Project configuration from platform */
interface ProjectConfig {
    appId: string;
    name: string;
    payTo: string;
    network: string;
    status: string;
}
/**
 * Initialize platform validation
 *
 * Reads APP_ID from environment and validates with platform API.
 * Uses singleton pattern - multiple calls return same promise.
 *
 * @returns Project configuration from platform
 * @throws Error if APP_ID is not set or validation fails
 */
declare function initializePlatform(): Promise<ProjectConfig>;
/**
 * Get cached project configuration
 *
 * @throws Error if platform not initialized
 */
declare function getProjectConfig(): ProjectConfig;

declare class MNTAgentKit {
    account: PrivateKeyAccount;
    client: WalletClient<Transport, Chain, PrivateKeyAccount> & PublicActions & Erc7811Actions;
    chain: "testnet" | "mainnet";
    demo: boolean;
    projectConfig?: ProjectConfig;
    constructor(privateKey: Address$1, chain: "mainnet" | "testnet" | "testnet-demo");
    /**
     * Initialize the agent with platform validation
     *
     * Validates APP_ID with the platform API.
     * Must be called after creating the agent instance.
     *
     * @returns The initialized agent instance
     * @throws Error if APP_ID is not set or validation fails
     *
     * @example
     * ```typescript
     * const agent = new MNTAgentKit(privateKey, "mainnet");
     * await agent.initialize(); // Validates APP_ID
     * ```
     */
    initialize(): Promise<MNTAgentKit>;
    sendTransaction(to: Address$1, amount: string): Promise<viem.TransactionReceipt<bigint, number, "success" | "reverted", viem.TransactionType> | {
        transactionHash: `0x${string}`;
        status: "success";
        blockNumber: bigint;
        blockHash: `0x${string}`;
        from: `0x${string}`;
        to: `0x${string}`;
        value: bigint;
        gasUsed: bigint;
        effectiveGasPrice: bigint;
        cumulativeGasUsed: bigint;
        logs: never[];
        logsBloom: `0x${string}`;
        type: "eip1559";
    }>;
    getSwapQuote(fromTokenAddress: string, toTokenAddress: string, amount: string, slippagePercentage?: string): Promise<any>;
    getTokens(): Promise<OKXToken[]>;
    executeSwap(fromTokenAddress: string, toTokenAddress: string, amount: string, slippagePercentage?: string): Promise<{
        data: any;
    }>;
    getOpenOceanQuote(fromToken: Address$1, toToken: Address$1, amount: string): Promise<OpenOceanQuote>;
    swapOnOpenOcean(fromToken: Address$1, toToken: Address$1, amount: string, slippage?: number): Promise<{
        txHash: string;
        outAmount: string;
    }>;
    getOpenOceanTokens(): Promise<OpenOceanToken[]>;
    getUniswapQuote(fromToken: Address$1, toToken: Address$1, amount: string): Promise<UniswapQuoteResult>;
    swapOnUniswap(fromToken: Address$1, toToken: Address$1, amount: string, slippage?: number): Promise<{
        txHash: string;
        amountOut: string;
    }>;
    lendleSupply(tokenAddress: Address$1, amount: string): Promise<`0x${string}`>;
    lendleWithdraw(tokenAddress: Address$1, amount: string, to?: Address$1): Promise<`0x${string}`>;
    lendleBorrow(tokenAddress: Address$1, amount: string, interestRateMode?: 1 | 2, onBehalfOf?: Address$1): Promise<`0x${string}`>;
    lendleRepay(tokenAddress: Address$1, amount: string, rateMode?: 1 | 2, onBehalfOf?: Address$1): Promise<`0x${string}`>;
    /**
     * Get user account data from Lendle LendingPool
     * Returns overall position including total collateral, debt, and health factor
     * @param userAddress - User wallet address (optional, defaults to agent account)
     * @returns User account data with collateral, debt, available borrows, and health factor
     */
    lendleGetUserAccountData(userAddress?: Address$1): Promise<UserAccountData>;
    /**
     * Get all Lendle positions for a user (per-token breakdown)
     * Returns detailed supply and borrow amounts for each asset
     * @param userAddress - User wallet address (optional, defaults to agent account)
     * @returns Array of positions with supply/borrow amounts per asset
     */
    lendleGetPositions(userAddress?: Address$1): Promise<LendlePositionsResult>;
    agniSwap(tokenIn: Address$1, tokenOut: Address$1, amountIn: string, slippagePercent?: number, feeTier?: number): Promise<`0x${string}`>;
    merchantMoeSwap(tokenIn: Address$1, tokenOut: Address$1, amountIn: string, slippagePercent?: number, binStep?: number): Promise<`0x${string}`>;
    getMethTokenAddress(): "0x0000000000000000000000000000000000000000" | "0xcDA86A272531e8640cD7F1a92c01839911B90bb0";
    /**
     * Get mETH staking position for a user
     * Returns mETH balance and WETH balance for comparison
     * @param userAddress - User wallet address (optional, defaults to agent account)
     * @returns mETH position with balances
     */
    methGetPosition(userAddress?: Address$1): Promise<MethPosition>;
    /**
     * Swap WETH to mETH using DEX aggregator
     * @param amount - Amount of WETH to swap (in wei as string)
     * @param slippage - Slippage tolerance percentage (default 0.5%)
     * @returns Transaction hash
     */
    swapToMeth(amount: string, slippage?: number): Promise<`0x${string}`>;
    /**
     * Swap mETH to WETH using DEX aggregator
     * @param amount - Amount of mETH to swap (in wei as string)
     * @param slippage - Slippage tolerance percentage (default 0.5%)
     * @returns Transaction hash
     */
    swapFromMeth(amount: string, slippage?: number): Promise<`0x${string}`>;
    getSquidRoute(fromToken: Address$1, toToken: Address$1, fromChain: number, toChain: number, amount: string, slippage?: number): Promise<{
        route: {
            estimate: {
                toAmount: string;
            };
            transactionRequest: {
                targetAddress: string;
                data: string;
                value: string;
                gasLimit: string;
            };
        };
        demo: boolean;
        message: string;
    } | SquidRoute>;
    crossChainSwapViaSquid(fromToken: Address$1, toToken: Address$1, fromChain: number, toChain: number, amount: string, slippage?: number): Promise<`0x${string}`>;
    /**
     * Open a long position on PikePerps
     * @param tokenAddress - Token to trade (meme token address)
     * @param margin - Margin amount in wei (as string)
     * @param leverage - Leverage multiplier (1-100, default 10)
     * @returns Position ID and transaction hash
     */
    pikeperpsOpenLong(tokenAddress: Address$1, margin: string, leverage?: number): Promise<OpenPositionResult>;
    /**
     * Open a short position on PikePerps
     * @param tokenAddress - Token to trade (meme token address)
     * @param margin - Margin amount in wei (as string)
     * @param leverage - Leverage multiplier (1-100, default 10)
     * @returns Position ID and transaction hash
     */
    pikeperpsOpenShort(tokenAddress: Address$1, margin: string, leverage?: number): Promise<OpenPositionResult$1>;
    /**
     * Close an existing position on PikePerps
     * @param positionId - Position ID to close
     * @returns Transaction hash
     */
    pikeperpsClosePosition(positionId: bigint): Promise<`0x${string}`>;
    /**
     * Get all positions for a user on PikePerps
     * Returns detailed position data including PnL and liquidation prices
     * @param userAddress - User wallet address (optional, defaults to agent account)
     * @returns Array of positions with PnL and liquidation data
     */
    pikeperpsGetPositions(userAddress?: Address$1): Promise<PikePerpsPosition[]>;
    /**
     * Get market data for a token on PikePerps
     * Returns current price and recent trades
     * @param tokenAddress - Token address to get market data for
     * @param limit - Maximum number of recent trades to return (default 20)
     * @returns Market data with price and recent trades
     */
    pikeperpsGetMarketData(tokenAddress: Address$1, limit?: number): Promise<PikePerpsMarketData>;
    /**
     * Get real-time price from Pyth Network
     * Accepts token address, pair name, or price feed ID
     * @param input - Token address (e.g., "0x09Bc4E0D10C81b3a3766c49F0f98a8aaa7adA8D2" for USDC),
     *                pair name (e.g., "ETH/USD"), or price feed ID (hex string)
     * @returns Price data with formatted price
     * @example
     * // Using pair name
     * await agent.pythGetPrice("ETH/USD");
     * // Using token address (USDC on Mantle)
     * await agent.pythGetPrice("0x09Bc4E0D10C81b3a3766c49F0f98a8aaa7adA8D2");
     */
    pythGetPrice(input: string): Promise<PythPriceResponse>;
    /**
     * Get EMA (Exponential Moving Average) price from Pyth
     * Accepts token address, pair name, or price feed ID
     * @param input - Token address, pair name, or price feed ID
     * @returns EMA price data
     */
    pythGetEmaPrice(input: string): Promise<PythPriceResponse>;
    /**
     * Get price for a token by its contract address
     * Pass any supported token address and get the USD price with full details
     * @param tokenAddress - Token contract address on Mantle
     * @returns Token price details including symbol, USD price, and timestamp
     * @example
     * const price = await agent.pythGetTokenPrice("0x09Bc4E0D10C81b3a3766c49F0f98a8aaa7adA8D2");
     * // Returns: {
     * //   tokenAddress: "0x09Bc4E0D10C81b3a3766c49F0f98a8aaa7adA8D2",
     * //   tokenSymbol: "USDC",
     * //   pair: "USDC/USD",
     * //   priceUsd: "1.00",
     * //   lastUpdated: "2024-01-08T12:00:00.000Z"
     * // }
     */
    pythGetTokenPrice(tokenAddress: string): Promise<PythTokenPriceResponse>;
    /**
     * Get multiple prices from Pyth in a single call
     * Accepts token addresses, pair names, or price feed IDs
     * @param inputs - Array of token addresses, pair names, or price feed IDs
     * @returns Array of price responses
     * @example
     * await agent.pythGetMultiplePrices([
     *   "ETH/USD",                                           // pair name
     *   "0x09Bc4E0D10C81b3a3766c49F0f98a8aaa7adA8D2",       // USDC address
     *   "0xcDA86A272531e8640cD7F1a92c01839911B90bb0",       // mETH address
     * ]);
     */
    pythGetMultiplePrices(inputs: string[]): Promise<PythPriceResponse[]>;
    /**
     * Get all supported Pyth price feed IDs
     * @returns Object mapping pair names to price feed IDs
     */
    pythGetSupportedPriceFeeds(): Record<string, string>;
    /**
     * Get all supported token addresses for Pyth price lookups on Mantle
     * @returns Object mapping token addresses to their pair names
     * @example
     * const addresses = agent.pythGetSupportedTokenAddresses();
     * // Returns: { "0x09Bc4E0D10C81b3a3766c49F0f98a8aaa7adA8D2": "USDC/USD", ... }
     */
    pythGetSupportedTokenAddresses(): Record<string, string>;
    /**
     * Check if a price feed exists on Pyth
     * Accepts token address, pair name, or price feed ID
     * @param input - Token address, pair name, or price feed ID
     * @returns Boolean indicating if feed exists
     */
    pythPriceFeedExists(input: string): Promise<boolean>;
    /**
     * Deploy a new token (ERC20 or RWA) - supply minted to your address
     * @param name - Token name
     * @param symbol - Token symbol
     * @param supply - Total supply (human readable, e.g., "1000000")
     * @param tokenType - "standard" or "rwa"
     * @param assetType - For RWA: asset category
     * @param assetId - For RWA: external asset ID
     */
    deployToken(name: string, symbol: string, supply: string, tokenType?: TokenType, assetType?: string, assetId?: string): Promise<TokenDeploymentResult>;
    /**
     * Deploy a standard ERC20 token
     * @param name - Token name
     * @param symbol - Token symbol
     * @param supply - Total supply (e.g., "1000000" for 1M tokens)
     */
    deployStandardToken(name: string, symbol: string, supply: string): Promise<TokenDeploymentResult>;
    /**
     * Deploy an RWA (Real World Asset) token
     * @param name - Token name (e.g., "Manhattan Property Token")
     * @param symbol - Token symbol (e.g., "MPT")
     * @param supply - Total supply for fractional ownership
     * @param assetType - Asset category: "Real Estate", "Commodities", "Securities", "Art"
     * @param assetId - External reference ID for the underlying asset
     */
    deployRWAToken(name: string, symbol: string, supply: string, assetType: string, assetId?: string): Promise<TokenDeploymentResult>;
    /**
     * Get token information
     */
    getTokenInfo(tokenAddress: Address$1, holder?: Address$1): Promise<TokenInfo>;
    /**
     * Get token balance
     */
    getTokenBalance(tokenAddress: Address$1, holder?: Address$1): Promise<string>;
    /**
     * Transfer tokens
     */
    transferToken(tokenAddress: Address$1, to: Address$1, amount: string): Promise<`0x${string}`>;
    /**
     * Deploy a new ERC721 NFT collection on Mantle Network
     * @param config - Collection configuration (name, symbol, baseURI, maxSupply)
     * @returns Collection deployment result with contract address
     */
    deployNFTCollection(config: NFTCollectionConfig): Promise<NFTCollectionDeploymentResult>;
    /**
     * Deploy an NFT collection with preset configurations
     * @param preset - Preset type: "pfp" (10000), "art" (1000), "membership" (100), "unlimited"
     * @param name - Collection name
     * @param symbol - Collection symbol
     * @param baseURI - Base URI for metadata
     * @returns Collection deployment result
     */
    deployNFTCollectionWithPreset(preset: "pfp" | "art" | "membership" | "unlimited", name: string, symbol: string, baseURI: string): Promise<NFTCollectionDeploymentResult>;
    /**
     * Mint a single NFT from a collection
     * @param collectionAddress - NFT collection contract address
     * @param to - Recipient address (defaults to agent address)
     * @returns Mint result with token ID
     */
    mintNFT(collectionAddress: Address$1, to?: Address$1): Promise<NFTMintResult>;
    /**
     * Batch mint multiple NFTs from a collection
     * @param collectionAddress - NFT collection contract address
     * @param to - Recipient address
     * @param quantity - Number of NFTs to mint
     * @returns Mint result with starting token ID
     */
    batchMintNFT(collectionAddress: Address$1, to: Address$1, quantity: number): Promise<{
        txHash: viem.Hex;
        startTokenId: string;
        quantity: number;
    }>;
    /**
     * Get information about an NFT collection
     * @param collectionAddress - NFT collection contract address
     * @param holderAddress - Optional address to get balance for
     * @returns Collection information
     */
    getNFTCollectionInfo(collectionAddress: Address$1, holderAddress?: Address$1): Promise<NFTCollectionInfo>;
    /**
     * Get information about a specific NFT token
     * @param collectionAddress - NFT collection contract address
     * @param tokenId - Token ID
     * @returns Token information
     */
    getNFTTokenInfo(collectionAddress: Address$1, tokenId: string): Promise<NFTTokenInfo>;
    /**
     * Get NFT balance for an address
     * @param collectionAddress - NFT collection contract address
     * @param holderAddress - Address to check (defaults to agent address)
     * @returns Balance as string
     */
    getNFTBalance(collectionAddress: Address$1, holderAddress?: Address$1): Promise<string>;
    /**
     * Check if an address owns a specific NFT
     * @param collectionAddress - NFT collection contract address
     * @param tokenId - Token ID to check
     * @param ownerAddress - Address to verify ownership
     * @returns Boolean indicating ownership
     */
    isNFTOwner(collectionAddress: Address$1, tokenId: string, ownerAddress?: Address$1): Promise<boolean>;
    /**
     * Transfer an NFT to another address
     * @param collectionAddress - NFT collection contract address
     * @param to - Recipient address
     * @param tokenId - Token ID to transfer
     * @returns Transaction hash
     */
    transferNFT(collectionAddress: Address$1, to: Address$1, tokenId: string): Promise<`0x${string}`>;
    /**
     * Safe transfer an NFT (checks if recipient can receive)
     * @param collectionAddress - NFT collection contract address
     * @param to - Recipient address
     * @param tokenId - Token ID to transfer
     * @returns Transaction hash
     */
    safeTransferNFT(collectionAddress: Address$1, to: Address$1, tokenId: string): Promise<`0x${string}`>;
    /**
     * Approve an address to transfer a specific NFT
     * @param collectionAddress - NFT collection contract address
     * @param approved - Address to approve
     * @param tokenId - Token ID to approve
     * @returns Transaction hash
     */
    approveNFT(collectionAddress: Address$1, approved: Address$1, tokenId: string): Promise<`0x${string}`>;
    /**
     * Set approval for all NFTs in a collection
     * @param collectionAddress - NFT collection contract address
     * @param operator - Operator address
     * @param approved - Whether to approve or revoke
     * @returns Transaction hash
     */
    setApprovalForAllNFT(collectionAddress: Address$1, operator: Address$1, approved: boolean): Promise<`0x${string}`>;
}

declare const FACTORY: {
    readonly mainnet: "0x25780dc8Fc3cfBD75F33bFDAB65e969b603b2035";
    readonly testnet: "0x0000000000000000000000000000000000000000";
};
declare const SWAP_ROUTER: {
    readonly mainnet: "0x319B69888b0d11cEC22caA5034e25FfFBDc88421";
    readonly testnet: "0x0000000000000000000000000000000000000000";
};
declare const POSITION_MANAGER: {
    readonly mainnet: "0x218bf598d1453383e2f4aa7b14ffb9bfb102d637";
    readonly testnet: "0x0000000000000000000000000000000000000000";
};
declare const WMNT$1: {
    readonly mainnet: "0x78c1b0C915c4FAA5FffA6CAbf0219DA63d7f4cb8";
    readonly testnet: "0x0000000000000000000000000000000000000000";
};
declare const SWAP_ROUTER_ABI: readonly [{
    readonly inputs: readonly [{
        readonly components: readonly [{
            readonly name: "tokenIn";
            readonly type: "address";
        }, {
            readonly name: "tokenOut";
            readonly type: "address";
        }, {
            readonly name: "fee";
            readonly type: "uint24";
        }, {
            readonly name: "recipient";
            readonly type: "address";
        }, {
            readonly name: "deadline";
            readonly type: "uint256";
        }, {
            readonly name: "amountIn";
            readonly type: "uint256";
        }, {
            readonly name: "amountOutMinimum";
            readonly type: "uint256";
        }, {
            readonly name: "sqrtPriceLimitX96";
            readonly type: "uint160";
        }];
        readonly name: "params";
        readonly type: "tuple";
    }];
    readonly name: "exactInputSingle";
    readonly outputs: readonly [{
        readonly name: "amountOut";
        readonly type: "uint256";
    }];
    readonly stateMutability: "payable";
    readonly type: "function";
}];
declare const FEE_TIERS: {
    readonly LOWEST: 100;
    readonly LOW: 500;
    readonly MEDIUM: 3000;
    readonly HIGH: 10000;
};

declare const index$6_FACTORY: typeof FACTORY;
declare const index$6_FEE_TIERS: typeof FEE_TIERS;
declare const index$6_POSITION_MANAGER: typeof POSITION_MANAGER;
declare const index$6_SWAP_ROUTER: typeof SWAP_ROUTER;
declare const index$6_SWAP_ROUTER_ABI: typeof SWAP_ROUTER_ABI;
declare namespace index$6 {
  export { index$6_FACTORY as FACTORY, index$6_FEE_TIERS as FEE_TIERS, index$6_POSITION_MANAGER as POSITION_MANAGER, index$6_SWAP_ROUTER as SWAP_ROUTER, index$6_SWAP_ROUTER_ABI as SWAP_ROUTER_ABI, WMNT$1 as WMNT };
}

declare const LENDING_POOL: {
    readonly mainnet: "0xCFa5aE7c2CE8Fadc6426C1ff872cA45378Fb7cF3";
    readonly testnet: "0x0000000000000000000000000000000000000000";
};
declare const LENDING_POOL_ADDRESSES_PROVIDER: {
    readonly mainnet: "0xAb94Bedd21ae3411eB2698945dfCab1D5C19C3d4";
    readonly testnet: "0x0000000000000000000000000000000000000000";
};
declare const PROTOCOL_DATA_PROVIDER: {
    readonly mainnet: "0x552b9e4bae485C4B7F540777d7D25614CdB84773";
    readonly testnet: "0x0000000000000000000000000000000000000000";
};
declare const ORACLE: {
    readonly mainnet: "0x870c9692Ab04944C86ec6FEeF63F261226506EfC";
    readonly testnet: "0x0000000000000000000000000000000000000000";
};
declare const WMNT_ADDRESS: "0x78c1b0C915c4FAA5FffA6CAbf0219DA63d7f4cb8";
declare const INTEREST_RATE_MODE: {
    readonly STABLE: 1;
    readonly VARIABLE: 2;
};
declare const LENDING_POOL_ABI: readonly [{
    readonly inputs: readonly [{
        readonly name: "asset";
        readonly type: "address";
    }, {
        readonly name: "amount";
        readonly type: "uint256";
    }, {
        readonly name: "onBehalfOf";
        readonly type: "address";
    }, {
        readonly name: "referralCode";
        readonly type: "uint16";
    }];
    readonly name: "deposit";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "asset";
        readonly type: "address";
    }, {
        readonly name: "amount";
        readonly type: "uint256";
    }, {
        readonly name: "to";
        readonly type: "address";
    }];
    readonly name: "withdraw";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "asset";
        readonly type: "address";
    }, {
        readonly name: "amount";
        readonly type: "uint256";
    }, {
        readonly name: "interestRateMode";
        readonly type: "uint256";
    }, {
        readonly name: "referralCode";
        readonly type: "uint16";
    }, {
        readonly name: "onBehalfOf";
        readonly type: "address";
    }];
    readonly name: "borrow";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "asset";
        readonly type: "address";
    }, {
        readonly name: "amount";
        readonly type: "uint256";
    }, {
        readonly name: "rateMode";
        readonly type: "uint256";
    }, {
        readonly name: "onBehalfOf";
        readonly type: "address";
    }];
    readonly name: "repay";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "user";
        readonly type: "address";
    }];
    readonly name: "getUserAccountData";
    readonly outputs: readonly [{
        readonly name: "totalCollateralETH";
        readonly type: "uint256";
    }, {
        readonly name: "totalDebtETH";
        readonly type: "uint256";
    }, {
        readonly name: "availableBorrowsETH";
        readonly type: "uint256";
    }, {
        readonly name: "currentLiquidationThreshold";
        readonly type: "uint256";
    }, {
        readonly name: "ltv";
        readonly type: "uint256";
    }, {
        readonly name: "healthFactor";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "asset";
        readonly type: "address";
    }];
    readonly name: "getReserveData";
    readonly outputs: readonly [{
        readonly components: readonly [{
            readonly name: "configuration";
            readonly type: "uint256";
        }, {
            readonly name: "liquidityIndex";
            readonly type: "uint128";
        }, {
            readonly name: "variableBorrowIndex";
            readonly type: "uint128";
        }, {
            readonly name: "currentLiquidityRate";
            readonly type: "uint128";
        }, {
            readonly name: "currentVariableBorrowRate";
            readonly type: "uint128";
        }, {
            readonly name: "currentStableBorrowRate";
            readonly type: "uint128";
        }, {
            readonly name: "lastUpdateTimestamp";
            readonly type: "uint40";
        }, {
            readonly name: "aTokenAddress";
            readonly type: "address";
        }, {
            readonly name: "stableDebtTokenAddress";
            readonly type: "address";
        }, {
            readonly name: "variableDebtTokenAddress";
            readonly type: "address";
        }, {
            readonly name: "interestRateStrategyAddress";
            readonly type: "address";
        }, {
            readonly name: "id";
            readonly type: "uint8";
        }];
        readonly name: "";
        readonly type: "tuple";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}];
declare const PROTOCOL_DATA_PROVIDER_ABI: readonly [{
    readonly inputs: readonly [];
    readonly name: "getAllReservesTokens";
    readonly outputs: readonly [{
        readonly components: readonly [{
            readonly name: "symbol";
            readonly type: "string";
        }, {
            readonly name: "tokenAddress";
            readonly type: "address";
        }];
        readonly name: "";
        readonly type: "tuple[]";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "asset";
        readonly type: "address";
    }, {
        readonly name: "user";
        readonly type: "address";
    }];
    readonly name: "getUserReserveData";
    readonly outputs: readonly [{
        readonly name: "currentATokenBalance";
        readonly type: "uint256";
    }, {
        readonly name: "currentStableDebt";
        readonly type: "uint256";
    }, {
        readonly name: "currentVariableDebt";
        readonly type: "uint256";
    }, {
        readonly name: "principalStableDebt";
        readonly type: "uint256";
    }, {
        readonly name: "scaledVariableDebt";
        readonly type: "uint256";
    }, {
        readonly name: "stableBorrowRate";
        readonly type: "uint256";
    }, {
        readonly name: "liquidityRate";
        readonly type: "uint256";
    }, {
        readonly name: "stableRateLastUpdated";
        readonly type: "uint40";
    }, {
        readonly name: "usageAsCollateralEnabled";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "asset";
        readonly type: "address";
    }];
    readonly name: "getReserveTokensAddresses";
    readonly outputs: readonly [{
        readonly name: "aTokenAddress";
        readonly type: "address";
    }, {
        readonly name: "stableDebtTokenAddress";
        readonly type: "address";
    }, {
        readonly name: "variableDebtTokenAddress";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}];
declare const LENDLE_SUPPORTED_ASSETS: {
    readonly mainnet: readonly [{
        readonly symbol: "WMNT";
        readonly address: "0x78c1b0C915c4FAA5FffA6CAbf0219DA63d7f4cb8";
    }, {
        readonly symbol: "WETH";
        readonly address: "0xdEAddEaDdeadDEadDEADDEAddEADDEAddead1111";
    }, {
        readonly symbol: "USDC";
        readonly address: "0x09Bc4E0D10C81b3a3766c49F0f98a8aaa7adA8D2";
    }, {
        readonly symbol: "USDT";
        readonly address: "0x201EBa5CC46D216Ce6DC03F6a759e8E766e956aE";
    }, {
        readonly symbol: "mETH";
        readonly address: "0xcDA86A272531e8640cD7F1a92c01839911B90bb0";
    }];
    readonly testnet: readonly [];
};

declare const index$5_INTEREST_RATE_MODE: typeof INTEREST_RATE_MODE;
declare const index$5_LENDING_POOL: typeof LENDING_POOL;
declare const index$5_LENDING_POOL_ABI: typeof LENDING_POOL_ABI;
declare const index$5_LENDING_POOL_ADDRESSES_PROVIDER: typeof LENDING_POOL_ADDRESSES_PROVIDER;
declare const index$5_LENDLE_SUPPORTED_ASSETS: typeof LENDLE_SUPPORTED_ASSETS;
declare const index$5_ORACLE: typeof ORACLE;
declare const index$5_PROTOCOL_DATA_PROVIDER: typeof PROTOCOL_DATA_PROVIDER;
declare const index$5_PROTOCOL_DATA_PROVIDER_ABI: typeof PROTOCOL_DATA_PROVIDER_ABI;
declare const index$5_WMNT_ADDRESS: typeof WMNT_ADDRESS;
declare namespace index$5 {
  export { index$5_INTEREST_RATE_MODE as INTEREST_RATE_MODE, index$5_LENDING_POOL as LENDING_POOL, index$5_LENDING_POOL_ABI as LENDING_POOL_ABI, index$5_LENDING_POOL_ADDRESSES_PROVIDER as LENDING_POOL_ADDRESSES_PROVIDER, index$5_LENDLE_SUPPORTED_ASSETS as LENDLE_SUPPORTED_ASSETS, index$5_ORACLE as ORACLE, index$5_PROTOCOL_DATA_PROVIDER as PROTOCOL_DATA_PROVIDER, index$5_PROTOCOL_DATA_PROVIDER_ABI as PROTOCOL_DATA_PROVIDER_ABI, index$5_WMNT_ADDRESS as WMNT_ADDRESS };
}

declare const LB_ROUTER: {
    readonly mainnet: "0x013e138EF6008ae5FDFDE29700e3f2Bc61d21E3a";
    readonly testnet: "0x0000000000000000000000000000000000000000";
};
declare const LB_FACTORY: {
    readonly mainnet: "0xa6630671775c4EA2743840F9A5016dCf2A104054";
    readonly testnet: "0x0000000000000000000000000000000000000000";
};
declare const LB_QUOTER: {
    readonly mainnet: "0x501b8AFd35df20f531fF45F6f695793AC3316c85";
    readonly testnet: "0x0000000000000000000000000000000000000000";
};
declare const WMNT: {
    readonly mainnet: "0x78c1b0C915c4FAA5FffA6CAbf0219DA63d7f4cb8";
    readonly testnet: "0x0000000000000000000000000000000000000000";
};
declare const MOE_TOKEN: "0x4515a45337f461a11ff0fe8abf3c606ae5dc00c9";
declare const LB_VERSION: {
    readonly V1: 0;
    readonly V2: 1;
    readonly V2_1: 2;
    readonly V2_2: 3;
};
declare const DEFAULT_BIN_STEP = 15;
declare const LB_ROUTER_ABI: readonly [{
    readonly inputs: readonly [{
        readonly name: "amountOutMin";
        readonly type: "uint256";
    }, {
        readonly name: "path";
        readonly type: "tuple";
        readonly components: readonly [{
            readonly name: "pairBinSteps";
            readonly type: "uint256[]";
        }, {
            readonly name: "versions";
            readonly type: "uint8[]";
        }, {
            readonly name: "tokenPath";
            readonly type: "address[]";
        }];
    }, {
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly name: "deadline";
        readonly type: "uint256";
    }];
    readonly name: "swapExactNATIVEForTokens";
    readonly outputs: readonly [{
        readonly name: "amountOut";
        readonly type: "uint256";
    }];
    readonly stateMutability: "payable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "amountIn";
        readonly type: "uint256";
    }, {
        readonly name: "amountOutMin";
        readonly type: "uint256";
    }, {
        readonly name: "path";
        readonly type: "tuple";
        readonly components: readonly [{
            readonly name: "pairBinSteps";
            readonly type: "uint256[]";
        }, {
            readonly name: "versions";
            readonly type: "uint8[]";
        }, {
            readonly name: "tokenPath";
            readonly type: "address[]";
        }];
    }, {
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly name: "deadline";
        readonly type: "uint256";
    }];
    readonly name: "swapExactTokensForTokens";
    readonly outputs: readonly [{
        readonly name: "amountOut";
        readonly type: "uint256";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "amountIn";
        readonly type: "uint256";
    }, {
        readonly name: "amountOutMin";
        readonly type: "uint256";
    }, {
        readonly name: "path";
        readonly type: "tuple";
        readonly components: readonly [{
            readonly name: "pairBinSteps";
            readonly type: "uint256[]";
        }, {
            readonly name: "versions";
            readonly type: "uint8[]";
        }, {
            readonly name: "tokenPath";
            readonly type: "address[]";
        }];
    }, {
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly name: "deadline";
        readonly type: "uint256";
    }];
    readonly name: "swapExactTokensForNATIVE";
    readonly outputs: readonly [{
        readonly name: "amountOut";
        readonly type: "uint256";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}];
declare const LB_PAIR_ABI: readonly [{
    readonly inputs: readonly [];
    readonly name: "getTokenX";
    readonly outputs: readonly [{
        readonly name: "tokenX";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "getTokenY";
    readonly outputs: readonly [{
        readonly name: "tokenY";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "getReservesAndId";
    readonly outputs: readonly [{
        readonly name: "reserveX";
        readonly type: "uint128";
    }, {
        readonly name: "reserveY";
        readonly type: "uint128";
    }, {
        readonly name: "activeId";
        readonly type: "uint24";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}];
declare const LB_FACTORY_ABI: readonly [{
    readonly inputs: readonly [{
        readonly name: "tokenX";
        readonly type: "address";
    }, {
        readonly name: "tokenY";
        readonly type: "address";
    }];
    readonly name: "getAllLBPairs";
    readonly outputs: readonly [{
        readonly name: "lbPairsAvailable";
        readonly type: "tuple[]";
        readonly components: readonly [{
            readonly name: "binStep";
            readonly type: "uint16";
        }, {
            readonly name: "LBPair";
            readonly type: "address";
        }, {
            readonly name: "createdByOwner";
            readonly type: "bool";
        }, {
            readonly name: "ignoredForRouting";
            readonly type: "bool";
        }];
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}];

declare const index$4_DEFAULT_BIN_STEP: typeof DEFAULT_BIN_STEP;
declare const index$4_LB_FACTORY: typeof LB_FACTORY;
declare const index$4_LB_FACTORY_ABI: typeof LB_FACTORY_ABI;
declare const index$4_LB_PAIR_ABI: typeof LB_PAIR_ABI;
declare const index$4_LB_QUOTER: typeof LB_QUOTER;
declare const index$4_LB_ROUTER: typeof LB_ROUTER;
declare const index$4_LB_ROUTER_ABI: typeof LB_ROUTER_ABI;
declare const index$4_LB_VERSION: typeof LB_VERSION;
declare const index$4_MOE_TOKEN: typeof MOE_TOKEN;
declare const index$4_WMNT: typeof WMNT;
declare namespace index$4 {
  export { index$4_DEFAULT_BIN_STEP as DEFAULT_BIN_STEP, index$4_LB_FACTORY as LB_FACTORY, index$4_LB_FACTORY_ABI as LB_FACTORY_ABI, index$4_LB_PAIR_ABI as LB_PAIR_ABI, index$4_LB_QUOTER as LB_QUOTER, index$4_LB_ROUTER as LB_ROUTER, index$4_LB_ROUTER_ABI as LB_ROUTER_ABI, index$4_LB_VERSION as LB_VERSION, index$4_MOE_TOKEN as MOE_TOKEN, index$4_WMNT as WMNT };
}

declare const configs: {
    apiKey: string | undefined;
    secretKey: string | undefined;
    apiPassphrase: string | undefined;
    projectId: string | undefined;
};
declare const baseUrl: string;
declare const ETH_ADDRESS = "0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000";

declare const index$3_ETH_ADDRESS: typeof ETH_ADDRESS;
declare const index$3_baseUrl: typeof baseUrl;
declare const index$3_configs: typeof configs;
declare namespace index$3 {
  export { index$3_ETH_ADDRESS as ETH_ADDRESS, index$3_baseUrl as baseUrl, index$3_configs as configs };
}

declare const OPENOCEAN_BASE_URL = "https://open-api.openocean.finance/v4";
declare const OPENOCEAN_CHAIN: {
    readonly mainnet: "mantle";
    readonly testnet: "mantle";
};
declare const NATIVE_TOKEN_ADDRESS$1 = "0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000";
declare const OPENOCEAN_EXCHANGE_PROXY = "0x6352a56caadC4F1E25CD6c75970Fa768A3304e64";

declare const index$2_OPENOCEAN_BASE_URL: typeof OPENOCEAN_BASE_URL;
declare const index$2_OPENOCEAN_CHAIN: typeof OPENOCEAN_CHAIN;
declare const index$2_OPENOCEAN_EXCHANGE_PROXY: typeof OPENOCEAN_EXCHANGE_PROXY;
declare namespace index$2 {
  export { NATIVE_TOKEN_ADDRESS$1 as NATIVE_TOKEN_ADDRESS, index$2_OPENOCEAN_BASE_URL as OPENOCEAN_BASE_URL, index$2_OPENOCEAN_CHAIN as OPENOCEAN_CHAIN, index$2_OPENOCEAN_EXCHANGE_PROXY as OPENOCEAN_EXCHANGE_PROXY };
}

declare const SQUID_BASE_URL = "https://api.squidrouter.com/v2";
declare const SQUID_CHAIN_ID: {
    readonly mainnet: 5000;
    readonly testnet: 5003;
};
declare const DESTINATION_CHAINS: {
    readonly ethereum: 101;
    readonly arbitrum: 110;
    readonly optimism: 111;
    readonly polygon: 109;
    readonly base: 184;
    readonly bsc: 102;
    readonly avalanche: 106;
    readonly mantle: 5000;
};
declare const NATIVE_TOKEN_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";

declare const index$1_DESTINATION_CHAINS: typeof DESTINATION_CHAINS;
declare const index$1_NATIVE_TOKEN_ADDRESS: typeof NATIVE_TOKEN_ADDRESS;
declare const index$1_SQUID_BASE_URL: typeof SQUID_BASE_URL;
declare const index$1_SQUID_CHAIN_ID: typeof SQUID_CHAIN_ID;
declare namespace index$1 {
  export { index$1_DESTINATION_CHAINS as DESTINATION_CHAINS, index$1_NATIVE_TOKEN_ADDRESS as NATIVE_TOKEN_ADDRESS, index$1_SQUID_BASE_URL as SQUID_BASE_URL, index$1_SQUID_CHAIN_ID as SQUID_CHAIN_ID };
}

declare const PERPETUAL_TRADING: {
    readonly mainnet: "0x0000000000000000000000000000000000000000";
    readonly testnet: "0x8081b646f349c049f2d5e8a400057d411dd657bd";
};
declare const BONDING_CURVE_MARKET: {
    readonly mainnet: "0x0000000000000000000000000000000000000000";
    readonly testnet: "0x93b268325A9862645c82b32229f3B52264750Ca2";
};
declare const PIKE_PERPS_CONFIG: {
    readonly MAX_LEVERAGE: 100;
    readonly DEFAULT_LEVERAGE: 10;
    readonly MIN_LEVERAGE: 1;
    readonly TRADING_FEE_BPS: 5;
    readonly LIQUIDATION_REWARD_BPS: 500;
    readonly PRICE_DECIMALS: 8;
};
declare const PERPETUAL_TRADING_ABI: readonly [{
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "_pyth";
        readonly type: "address";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "constructor";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "uint256";
        readonly name: "positionId";
        readonly type: "uint256";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "user";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "pnl";
        readonly type: "uint256";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "exitPrice";
        readonly type: "uint256";
    }];
    readonly name: "PositionClosed";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "uint256";
        readonly name: "positionId";
        readonly type: "uint256";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "user";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "liquidationPrice";
        readonly type: "uint256";
    }];
    readonly name: "PositionLiquidated";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "uint256";
        readonly name: "positionId";
        readonly type: "uint256";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "user";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "token";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "bool";
        readonly name: "isLong";
        readonly type: "bool";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "size";
        readonly type: "uint256";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "margin";
        readonly type: "uint256";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "leverage";
        readonly type: "uint256";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "entryPrice";
        readonly type: "uint256";
    }];
    readonly name: "PositionOpened";
    readonly type: "event";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "_positionId";
        readonly type: "uint256";
    }];
    readonly name: "closePosition";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "_token";
        readonly type: "address";
    }];
    readonly name: "getCurrentPrice";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "currentPrice";
        readonly type: "uint256";
    }, {
        readonly internalType: "bool";
        readonly name: "hasPrice";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "_positionId";
        readonly type: "uint256";
    }];
    readonly name: "getLiquidationPrice";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "liquidationPrice";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "_positionId";
        readonly type: "uint256";
    }];
    readonly name: "getPosition";
    readonly outputs: readonly [{
        readonly components: readonly [{
            readonly internalType: "address";
            readonly name: "user";
            readonly type: "address";
        }, {
            readonly internalType: "address";
            readonly name: "token";
            readonly type: "address";
        }, {
            readonly internalType: "bool";
            readonly name: "isLong";
            readonly type: "bool";
        }, {
            readonly internalType: "uint256";
            readonly name: "size";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "margin";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "leverage";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "entryPrice";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "entryTime";
            readonly type: "uint256";
        }, {
            readonly internalType: "uint256";
            readonly name: "lastFundingTime";
            readonly type: "uint256";
        }, {
            readonly internalType: "bool";
            readonly name: "isOpen";
            readonly type: "bool";
        }];
        readonly internalType: "struct PerpetualTrading.Position";
        readonly name: "";
        readonly type: "tuple";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "_positionId";
        readonly type: "uint256";
    }];
    readonly name: "getPositionPnL";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "pnl";
        readonly type: "uint256";
    }, {
        readonly internalType: "bool";
        readonly name: "isProfit";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "_user";
        readonly type: "address";
    }];
    readonly name: "getUserPositions";
    readonly outputs: readonly [{
        readonly internalType: "uint256[]";
        readonly name: "";
        readonly type: "uint256[]";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "_positionId";
        readonly type: "uint256";
    }];
    readonly name: "liquidatePosition";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "maxLeverage";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "minMarginBps";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "nextPositionId";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "_token";
        readonly type: "address";
    }, {
        readonly internalType: "bool";
        readonly name: "_isLong";
        readonly type: "bool";
    }, {
        readonly internalType: "uint256";
        readonly name: "_margin";
        readonly type: "uint256";
    }, {
        readonly internalType: "uint256";
        readonly name: "_leverage";
        readonly type: "uint256";
    }];
    readonly name: "openPosition";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "positionId";
        readonly type: "uint256";
    }];
    readonly stateMutability: "payable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "_positionId";
        readonly type: "uint256";
    }];
    readonly name: "shouldLiquidate";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "tradingFeeBps";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}];
declare const BONDING_CURVE_MARKET_ABI: readonly [{
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "_token";
        readonly type: "address";
    }];
    readonly name: "getCurrentPrice";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "_token";
        readonly type: "address";
    }];
    readonly name: "isListed";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "_token";
        readonly type: "address";
    }];
    readonly name: "getCurveProgress";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}];

declare const index_BONDING_CURVE_MARKET: typeof BONDING_CURVE_MARKET;
declare const index_BONDING_CURVE_MARKET_ABI: typeof BONDING_CURVE_MARKET_ABI;
declare const index_PERPETUAL_TRADING: typeof PERPETUAL_TRADING;
declare const index_PERPETUAL_TRADING_ABI: typeof PERPETUAL_TRADING_ABI;
declare const index_PIKE_PERPS_CONFIG: typeof PIKE_PERPS_CONFIG;
declare namespace index {
  export { index_BONDING_CURVE_MARKET as BONDING_CURVE_MARKET, index_BONDING_CURVE_MARKET_ABI as BONDING_CURVE_MARKET_ABI, index_PERPETUAL_TRADING as PERPETUAL_TRADING, index_PERPETUAL_TRADING_ABI as PERPETUAL_TRADING_ABI, index_PIKE_PERPS_CONFIG as PIKE_PERPS_CONFIG };
}

interface UserAccountData {
    totalCollateralETH: bigint;
    totalDebtETH: bigint;
    availableBorrowsETH: bigint;
    currentLiquidationThreshold: bigint;
    ltv: bigint;
    healthFactor: bigint;
}

export { index$6 as AgniConstants, index$5 as LendleConstants, type LendlePosition, type LendlePositionsResult, METH_TOKEN, MNTAgentKit, index$4 as MerchantMoeConstants, index$9 as MethConstants, type MethPosition, type NFTCollectionConfig, type NFTCollectionDeploymentResult, type NFTCollectionInfo, index$7 as NFTLaunchpadConstants, type NFTMintResult, type NFTTokenInfo, index$3 as OKXConstants, type OKXToken, index$2 as OpenOceanConstants, type OpenOceanToken, index as PikePerpsConstants, type PikePerpsMarketData, type PikePerpsPosition, type PikePerpsTrade, type ProjectConfig, index$b as PythConstants, type PythPriceData, type PythPriceResponse, index$1 as SquidConstants, type TokenConfig, type TokenDeploymentResult, type TokenInfo, index$8 as TokenLaunchpadConstants, type TokenType, index$a as UniswapConstants, type UserAccountData, agniSwap, approveNFT, approveToken, batchMintNFT, crossChainSwapViaSquid, deployNFTCollection, deployNFTCollectionWithPreset, deployRWAToken, deployStandardToken, deployToken, executeSwap, getNFTBalance, getNFTCollectionInfo, getNFTTokenInfo, getOpenOceanQuote, getProjectConfig, getSquidRoute, getTokenBalance, getTokenInfo, getUniswapQuote, initializePlatform, isNFTOwner, lendleBorrow, lendleGetPositions, lendleRepay, lendleSupply, lendleWithdraw, merchantMoeSwap, methGetPosition, mintNFT, pikeperpsClosePosition, pikeperpsGetMarketData, pikeperpsGetPositions, pikeperpsOpenLong, pikeperpsOpenShort, pythGetEmaPrice, pythGetMultiplePrices, pythGetPrice, pythGetSupportedPriceFeeds, pythGetSupportedTokenAddresses, pythGetTokenPrice, pythPriceFeedExists, safeTransferNFT, sendTransaction, setApprovalForAllNFT, swapFromMeth, swapOnOpenOcean, swapOnUniswap, swapToMeth, transferNFT, transferToken };
