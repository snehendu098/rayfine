'use strict';

var viem = require('viem');
var accounts = require('viem/accounts');
var chains = require('viem/chains');
var actions = require('viem/actions');
var axios = require('axios');
var CryptoJS = require('crypto-js');
var experimental = require('viem/experimental');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var axios__default = /*#__PURE__*/_interopDefault(axios);
var CryptoJS__default = /*#__PURE__*/_interopDefault(CryptoJS);

var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var erc20Abi = [
  {
    name: "transfer",
    type: "function",
    inputs: [
      { name: "to", type: "address" },
      { name: "amount", type: "uint256" }
    ],
    outputs: [{ type: "bool" }]
  },
  {
    name: "decimals",
    type: "function",
    inputs: [],
    outputs: [{ type: "uint8" }]
  }
];
var sendTransaction = async (agent, to, amount, tokenAddress) => {
  if (agent.demo) {
    return {
      transactionHash: "0xdemo000000000000000000000000000000000000000000000000000000000001",
      status: "success",
      blockNumber: 1n,
      blockHash: "0xdemo000000000000000000000000000000000000000000000000000000000002",
      from: agent.account.address,
      to,
      value: tokenAddress ? 0n : viem.parseEther(amount),
      gasUsed: 21000n,
      effectiveGasPrice: 1n,
      cumulativeGasUsed: 21000n,
      logs: [],
      logsBloom: "0x",
      type: "eip1559"
    };
  }
  let hash;
  if (tokenAddress) {
    const decimals = await agent.client.readContract({
      address: tokenAddress,
      abi: erc20Abi,
      functionName: "decimals"
    });
    hash = await agent.client.writeContract({
      address: tokenAddress,
      abi: erc20Abi,
      functionName: "transfer",
      args: [to, viem.parseUnits(amount, decimals)]
    });
  } else {
    hash = await agent.client.sendTransaction({
      to,
      value: viem.parseEther(amount)
    });
  }
  const receipt = await actions.getTransactionReceipt(agent.client, {
    hash
  });
  return receipt;
};
async function checkAllowance(agent, tokenAddress, ownerAddress, spenderAddress) {
  try {
    const allowance = await agent.client.readContract({
      address: tokenAddress,
      abi: viem.erc20Abi,
      functionName: "allowance",
      args: [ownerAddress, spenderAddress]
    });
    return allowance;
  } catch (error) {
    console.error("Failed to query allowance:", error);
    throw error;
  }
}

// src/constants/okx/index.ts
var okx_exports = {};
__export(okx_exports, {
  ETH_ADDRESS: () => ETH_ADDRESS,
  baseUrl: () => baseUrl,
  configs: () => configs
});
var configs = {
  apiKey: process.env.OKX_API_KEY,
  secretKey: process.env.OKX_SECRET_KEY,
  apiPassphrase: process.env.OKX_API_PASSPHRASE,
  projectId: process.env.OKX_PROJECT_ID
};
var baseUrl = "https://web3.okx.com/api/v6/";
var ETH_ADDRESS = "0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000";
function getHeaders(timestamp, method, requestPath, queryString = "", body = "") {
  const { apiKey, secretKey, apiPassphrase, projectId } = configs;
  if (!apiKey || !secretKey || !apiPassphrase || !projectId) {
    throw new Error(
      "Missing required environment variables for API authentication"
    );
  }
  const stringToSign = timestamp + method + requestPath + (queryString || body);
  return {
    "Content-Type": "application/json",
    "OK-ACCESS-KEY": apiKey,
    "OK-ACCESS-SIGN": CryptoJS__default.default.enc.Base64.stringify(
      CryptoJS__default.default.HmacSHA256(stringToSign, secretKey)
    ),
    "OK-ACCESS-TIMESTAMP": timestamp,
    "OK-ACCESS-PASSPHRASE": apiPassphrase,
    "OK-ACCESS-PROJECT": projectId
  };
}

// src/utils/okx/getApproveTx.ts
async function getApproveTx(tokenAddress, amount, chainIndex) {
  try {
    const path = "dex/aggregator/approve-transaction";
    const url = `${baseUrl}${path}`;
    const params = {
      chainIndex,
      tokenContractAddress: tokenAddress,
      approveAmount: amount
    };
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    const requestPath = `/api/v6/${path}`;
    const queryString = "?" + new URLSearchParams(params).toString();
    const headers = getHeaders(timestamp, "GET", requestPath, queryString);
    const response = await axios__default.default.get(url, { params, headers });
    if (response.data.code === "0") {
      return response.data.data[0];
    } else {
      throw new Error(`API Error: ${response.data.msg || "Unknown error"}`);
    }
  } catch (error) {
    console.error(
      "Failed to get approval transaction data:",
      error.message
    );
    throw error;
  }
}
async function getGasLimit(fromAddress, toAddress, chainIndex, txAmount = "0", inputData = "") {
  try {
    const path = "dex/pre-transaction/gas-limit";
    const url = `https://web3.okx.com/api/v6/${path}`;
    const body = {
      chainIndex,
      fromAddress,
      toAddress,
      txAmount,
      extJson: {
        inputData
      }
    };
    const bodyString = JSON.stringify(body);
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    const requestPath = `/api/v6/${path}`;
    const headers = getHeaders(timestamp, "POST", requestPath, "", bodyString);
    const response = await axios__default.default.post(url, body, { headers });
    if (response.data.code === "0") {
      return response.data.data[0].gasLimit;
    } else {
      throw new Error(`API Error: ${response.data.msg || "Unknown error"}`);
    }
  } catch (error) {
    console.error("Failed to get gas limit:", error.message);
    throw error;
  }
}

// src/utils/okx/approveToken.ts
async function approveToken(agent, tokenAddress, amount) {
  const chainIndex = agent.chain === "mainnet" ? "5000" : "5003";
  const walletAddress = agent.account.address;
  const spenderAddress = "0x1f16A607a7f3F3044E477abFFc8BD33952cE306b";
  const currentAllowance = await checkAllowance(
    agent,
    tokenAddress,
    walletAddress,
    spenderAddress
  );
  if (currentAllowance >= BigInt(amount)) {
    console.log("Sufficient allowance already exists");
    return { allowanceExists: true, data: null };
  }
  console.log("Insufficient allowance, approving tokens...");
  const approveData = await getApproveTx(tokenAddress, amount, chainIndex);
  const gasLimit = await getGasLimit(
    walletAddress,
    tokenAddress,
    chainIndex,
    "0",
    approveData.data
  );
  const txObject = {
    to: tokenAddress,
    data: approveData.data,
    gas: gasLimit
  };
  return { allowanceExists: false, data: txObject };
}
async function getSwapTransaction(fromTokenAddress, toTokenAddress, amount, userWalletAddress, chainIndex, slippagePercent = "0.5") {
  try {
    const path = "dex/aggregator/swap";
    const url = `${baseUrl}${path}`;
    const params = {
      chainIndex,
      fromTokenAddress,
      toTokenAddress,
      amount,
      userWalletAddress,
      slippagePercent
    };
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    const requestPath = `/api/v6/${path}`;
    const queryString = "?" + new URLSearchParams(params).toString();
    const headers = getHeaders(timestamp, "GET", requestPath, queryString);
    const response = await axios__default.default.get(url, { params, headers });
    if (response.data.code === "0") {
      return response.data.data[0];
    } else {
      throw new Error(`API Error: ${response.data.msg || "Unknown error"}`);
    }
  } catch (error) {
    console.error(
      "Failed to get swap transaction data:",
      error.message
    );
    throw error;
  }
}
async function getTokens(chainIndex) {
  try {
    const path = "dex/aggregator/all-tokens";
    const url = `${baseUrl}${path}`;
    const params = { chainIndex };
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    const requestPath = `/api/v6/${path}`;
    const queryString = "?" + new URLSearchParams(params).toString();
    const headers = getHeaders(timestamp, "GET", requestPath, queryString);
    const response = await axios__default.default.get(url, { params, headers });
    if (response.data.code === "0") {
      return response.data.data;
    } else {
      throw new Error(`API Error: ${response.data.msg || "Unknown error"}`);
    }
  } catch (error) {
    console.error("Failed to get tokens:", error.message);
    throw error;
  }
}
async function getTokenDecimals(chainIndex, tokenAddress) {
  const tokens = await getTokens(chainIndex);
  const token = tokens.find(
    (t) => t.tokenContractAddress.toLowerCase() === tokenAddress.toLowerCase()
  );
  return token ? parseInt(token.decimals) : 18;
}
var DEMO_TX_HASH = "0xdemo000000000000000000000000000000000000000000000000000000000001";
function createMockSwapResponse(protocol, inputAmount) {
  return {
    txHash: DEMO_TX_HASH,
    amountOut: inputAmount,
    demo: true,
    message: `[DEMO] ${protocol} swap simulated`
  };
}
function createMockQuoteResponse(protocol, inputAmount) {
  return {
    estimatedAmount: inputAmount,
    demo: true,
    message: `[DEMO] ${protocol} quote simulated`
  };
}
function createMockLendleResponse(action, amount) {
  return {
    txHash: DEMO_TX_HASH,
    amount,
    demo: true,
    message: `[DEMO] Lendle ${action} simulated`
  };
}
function createMockTxHash() {
  return DEMO_TX_HASH;
}
function createMockOkxSwapResponse(inputAmount) {
  return {
    data: DEMO_TX_HASH,
    demo: true,
    message: "[DEMO] OKX swap simulated"
  };
}
function createMockOpenOceanSwapResponse(inputAmount) {
  return {
    txHash: DEMO_TX_HASH,
    outAmount: inputAmount,
    demo: true,
    message: "[DEMO] OpenOcean swap simulated"
  };
}
function createMockUniswapSwapResponse(inputAmount) {
  return {
    txHash: DEMO_TX_HASH,
    amountOut: inputAmount,
    demo: true,
    message: "[DEMO] Uniswap swap simulated"
  };
}
function createMockSquidRoute(amount) {
  return {
    route: {
      estimate: { toAmount: amount },
      transactionRequest: {
        targetAddress: "0x0000000000000000000000000000000000000000",
        data: "0x",
        value: "0",
        gasLimit: "0"
      }
    },
    demo: true,
    message: "[DEMO] Squid route simulated"
  };
}

// src/tools/okx/swap.ts
async function executeSwap(agent, fromTokenAddress, toTokenAddress, amount, slippagePercent) {
  if (agent.demo) {
    return createMockOkxSwapResponse();
  }
  const chainIndex = agent.chain === "mainnet" ? "5000" : "5003";
  const walletAddress = agent.account.address;
  if (fromTokenAddress !== ETH_ADDRESS) {
    const approval = await approveToken(agent, fromTokenAddress, amount);
    if (!approval.allowanceExists && approval.data) {
      const approveTxHash = await agent.client.sendTransaction({
        to: approval.data.to,
        data: approval.data.data,
        value: BigInt(0),
        gas: BigInt(approval.data.gas)
      });
      console.log(`Approval tx sent: ${approveTxHash}`);
      const approveReceipt = await agent.client.waitForTransactionReceipt({
        hash: approveTxHash
      });
      console.log(`Approval confirmed: ${approveReceipt.status}`);
    }
  }
  const swapData = await getSwapTransaction(
    fromTokenAddress,
    toTokenAddress,
    amount,
    walletAddress,
    chainIndex,
    slippagePercent
  );
  const txData = swapData.tx;
  console.log("Swap TX data received");
  const gasLimit = await getGasLimit(
    walletAddress,
    txData.to,
    chainIndex,
    txData.value || "0",
    txData.data
  );
  console.log("Gas limit received");
  const txHash = await agent.client.sendTransaction({
    to: txData.to,
    data: txData.data,
    value: BigInt(txData.value || "0"),
    gas: BigInt(gasLimit)
  });
  console.log(`Swap tx sent: ${txHash}`);
  const swapReceipt = await agent.client.waitForTransactionReceipt({
    hash: txHash
  });
  console.log(`Swap confirmed: ${swapReceipt.status}`);
  return {
    data: txHash
  };
}

// src/constants/openocean/index.ts
var openocean_exports = {};
__export(openocean_exports, {
  NATIVE_TOKEN_ADDRESS: () => NATIVE_TOKEN_ADDRESS,
  OPENOCEAN_BASE_URL: () => OPENOCEAN_BASE_URL,
  OPENOCEAN_CHAIN: () => OPENOCEAN_CHAIN,
  OPENOCEAN_EXCHANGE_PROXY: () => OPENOCEAN_EXCHANGE_PROXY
});
var OPENOCEAN_BASE_URL = "https://open-api.openocean.finance/v4";
var OPENOCEAN_CHAIN = {
  mainnet: "mantle",
  testnet: "mantle"
  // OpenOcean may not support testnet
};
var NATIVE_TOKEN_ADDRESS = "0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000";
var OPENOCEAN_EXCHANGE_PROXY = "0x6352a56caadC4F1E25CD6c75970Fa768A3304e64";

// src/helpers/openocean/index.ts
function getHeaders2(apiKey) {
  const headers = {
    "Content-Type": "application/json"
  };
  return headers;
}

// src/utils/openocean/getQuoteData.ts
async function getQuoteData(fromToken, toToken, amount, chain) {
  try {
    const chainName = OPENOCEAN_CHAIN[chain];
    const url = `${OPENOCEAN_BASE_URL}/${chainName}/quote`;
    const params = {
      inTokenAddress: fromToken,
      outTokenAddress: toToken,
      amount,
      gasPrice: "5"
      // Default gas price in gwei
    };
    const response = await axios__default.default.get(url, {
      params,
      headers: getHeaders2()
    });
    if (response.data.code === 200) {
      return response.data.data;
    } else {
      throw new Error(`OpenOcean API Error: ${response.data.message || "Unknown error"}`);
    }
  } catch (error) {
    console.error("Failed to get OpenOcean quote:", error.message);
    throw error;
  }
}
async function getSwapData(fromToken, toToken, amount, userAddress, slippage, chain) {
  try {
    const chainName = OPENOCEAN_CHAIN[chain];
    const url = `${OPENOCEAN_BASE_URL}/${chainName}/swap`;
    const params = {
      inTokenAddress: fromToken,
      outTokenAddress: toToken,
      amount,
      gasPrice: "5",
      // Default gas price in gwei
      slippage,
      account: userAddress
    };
    const response = await axios__default.default.get(url, {
      params,
      headers: getHeaders2()
    });
    if (response.data.code === 200) {
      return response.data.data;
    } else {
      throw new Error(`OpenOcean API Error: ${response.data.message || "Unknown error"}`);
    }
  } catch (error) {
    console.error("Failed to get OpenOcean swap data:", error.message);
    throw error;
  }
}
var tokenCache = null;
var CACHE_TTL = 5 * 60 * 1e3;
async function getTokenList(chain) {
  if (tokenCache && Date.now() - tokenCache.timestamp < CACHE_TTL) {
    return tokenCache.tokens;
  }
  try {
    const chainName = OPENOCEAN_CHAIN[chain];
    const url = `${OPENOCEAN_BASE_URL}/${chainName}/tokenList`;
    const response = await axios__default.default.get(url, {
      headers: getHeaders2()
    });
    if (response.data.code === 200) {
      tokenCache = {
        tokens: response.data.data,
        timestamp: Date.now()
      };
      return response.data.data;
    } else {
      throw new Error(
        `OpenOcean API Error: ${response.data.message || "Unknown error"}`
      );
    }
  } catch (error) {
    console.error("Failed to get OpenOcean token list:", error.message);
    throw error;
  }
}
async function getOpenOceanTokenDecimals(chain, tokenAddress) {
  const tokens = await getTokenList(chain);
  const token = tokens.find(
    (t) => t.address.toLowerCase() === tokenAddress.toLowerCase()
  );
  return token ? token.decimals : 18;
}

// src/tools/openocean/getQuote.ts
async function getOpenOceanQuote(agent, fromToken, toToken, amount) {
  if (agent.demo) {
    return createMockQuoteResponse("OpenOcean", amount);
  }
  return await getQuoteData(fromToken, toToken, amount, agent.chain);
}
async function checkAllowance2(agent, tokenAddress, ownerAddress, spenderAddress) {
  try {
    const allowance = await agent.client.readContract({
      address: tokenAddress,
      abi: viem.erc20Abi,
      functionName: "allowance",
      args: [ownerAddress, spenderAddress]
    });
    return allowance;
  } catch (error) {
    console.error("Failed to query allowance:", error);
    throw error;
  }
}
async function approveToken2(agent, tokenAddress, spenderAddress, amount) {
  const walletAddress = agent.account.address;
  const currentAllowance = await checkAllowance2(
    agent,
    tokenAddress,
    walletAddress,
    spenderAddress
  );
  if (currentAllowance >= BigInt(amount)) {
    console.log("Sufficient allowance already exists");
    return { approved: true, txHash: null };
  }
  console.log("Insufficient allowance, approving tokens...");
  const { encodeFunctionData: encodeFunctionData14 } = await import('viem');
  const approveData = encodeFunctionData14({
    abi: viem.erc20Abi,
    functionName: "approve",
    args: [spenderAddress, BigInt(amount)]
  });
  const gasEstimate = await agent.client.estimateGas({
    account: agent.account,
    to: tokenAddress,
    data: approveData
  });
  const txHash = await agent.client.sendTransaction({
    to: tokenAddress,
    data: approveData,
    value: BigInt(0),
    gas: gasEstimate
  });
  console.log(`Approval tx sent: ${txHash}`);
  const receipt = await agent.client.waitForTransactionReceipt({
    hash: txHash
  });
  console.log(`Approval confirmed: ${receipt.status}`);
  return { approved: true, txHash };
}

// src/tools/openocean/swap.ts
async function swapOnOpenOcean(agent, fromToken, toToken, amount, slippage = "1") {
  if (agent.demo) {
    return createMockOpenOceanSwapResponse(amount);
  }
  if (!agent.demo && agent.chain != "mainnet") {
    throw new Error("Openocean swaps happen only on mainnet");
  }
  const walletAddress = agent.account.address;
  const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
  const isNativeToken3 = fromToken.toLowerCase() === NATIVE_TOKEN_ADDRESS.toLowerCase() || fromToken.toLowerCase() === ZERO_ADDRESS.toLowerCase();
  if (!isNativeToken3) {
    const decimals = await getOpenOceanTokenDecimals(agent.chain, fromToken);
    const amountInSmallestUnit = viem.parseUnits(amount, decimals).toString();
    await approveToken2(agent, fromToken, OPENOCEAN_EXCHANGE_PROXY, amountInSmallestUnit);
  }
  const swapData = await getSwapData(
    fromToken,
    toToken,
    amount,
    walletAddress,
    slippage,
    agent.chain
  );
  console.log("OpenOcean swap data received");
  console.log(`Expected output: ${swapData.outAmount}`);
  const txHash = await agent.client.sendTransaction({
    to: swapData.to,
    data: swapData.data,
    value: BigInt(swapData.value || "0")
  });
  console.log(`OpenOcean swap tx sent: ${txHash}`);
  const receipt = await agent.client.waitForTransactionReceipt({
    hash: txHash
  });
  console.log(`Swap confirmed: ${receipt.status}`);
  return {
    txHash,
    outAmount: swapData.outAmount
  };
}

// src/constants/uniswap/index.ts
var uniswap_exports = {};
__export(uniswap_exports, {
  DEFAULT_POOL_FEE: () => DEFAULT_POOL_FEE,
  FACTORY_ADDRESS: () => FACTORY_ADDRESS,
  FEE_TIERS: () => FEE_TIERS,
  NATIVE_TOKEN_ADDRESS: () => NATIVE_TOKEN_ADDRESS2,
  QUOTER_V2_ADDRESS: () => QUOTER_V2_ADDRESS,
  SWAP_ROUTER_ADDRESS: () => SWAP_ROUTER_ADDRESS,
  WMNT_ADDRESS: () => WMNT_ADDRESS
});
var SWAP_ROUTER_ADDRESS = "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45";
var QUOTER_V2_ADDRESS = "0x61fFE014bA17989E743c5F6cB21bF9697530B21e";
var FACTORY_ADDRESS = "0x1F98431c8aD98523631AE4a59f267346ea31F984";
var WMNT_ADDRESS = "0x78c1b0C915c4FAA5FffA6CAbf0219DA63d7f4cb8";
var NATIVE_TOKEN_ADDRESS2 = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
var FEE_TIERS = {
  LOWEST: 100,
  // 0.01%
  LOW: 500,
  // 0.05%
  MEDIUM: 3e3,
  // 0.3%
  HIGH: 1e4
  // 1%
};
var DEFAULT_POOL_FEE = FEE_TIERS.MEDIUM;
var quoterV2Abi = [
  {
    inputs: [
      {
        components: [
          { name: "tokenIn", type: "address" },
          { name: "tokenOut", type: "address" },
          { name: "amountIn", type: "uint256" },
          { name: "fee", type: "uint24" },
          { name: "sqrtPriceLimitX96", type: "uint160" }
        ],
        name: "params",
        type: "tuple"
      }
    ],
    name: "quoteExactInputSingle",
    outputs: [
      { name: "amountOut", type: "uint256" },
      { name: "sqrtPriceX96After", type: "uint160" },
      { name: "initializedTicksCrossed", type: "uint32" },
      { name: "gasEstimate", type: "uint256" }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
var swapRouterAbi = [
  {
    inputs: [
      {
        components: [
          { name: "tokenIn", type: "address" },
          { name: "tokenOut", type: "address" },
          { name: "fee", type: "uint24" },
          { name: "recipient", type: "address" },
          { name: "amountIn", type: "uint256" },
          { name: "amountOutMinimum", type: "uint256" },
          { name: "sqrtPriceLimitX96", type: "uint160" }
        ],
        name: "params",
        type: "tuple"
      }
    ],
    name: "exactInputSingle",
    outputs: [{ name: "amountOut", type: "uint256" }],
    stateMutability: "payable",
    type: "function"
  }
];
function getTokenAddress(token) {
  if (token.toLowerCase() === NATIVE_TOKEN_ADDRESS2.toLowerCase()) {
    return WMNT_ADDRESS;
  }
  return token;
}
async function getUniswapQuoteData(agent, tokenIn, tokenOut, amountIn, fee = DEFAULT_POOL_FEE) {
  try {
    const result = await agent.client.simulateContract({
      address: QUOTER_V2_ADDRESS,
      abi: quoterV2Abi,
      functionName: "quoteExactInputSingle",
      args: [
        {
          tokenIn: getTokenAddress(tokenIn),
          tokenOut: getTokenAddress(tokenOut),
          amountIn: BigInt(amountIn),
          fee,
          sqrtPriceLimitX96: BigInt(0)
        }
      ]
    });
    const [amountOut, sqrtPriceX96After, , gasEstimate] = result.result;
    return {
      amountOut,
      sqrtPriceX96After,
      gasEstimate
    };
  } catch (error) {
    console.error("Failed to get Uniswap quote:", error);
    throw error;
  }
}
function buildSwapCalldata(params, fee = DEFAULT_POOL_FEE) {
  return viem.encodeFunctionData({
    abi: swapRouterAbi,
    functionName: "exactInputSingle",
    args: [
      {
        tokenIn: getTokenAddress(params.tokenIn),
        tokenOut: getTokenAddress(params.tokenOut),
        fee,
        recipient: params.recipient,
        amountIn: BigInt(params.amountIn),
        amountOutMinimum: BigInt(params.amountOutMinimum),
        sqrtPriceLimitX96: BigInt(0)
      }
    ]
  });
}

// src/tools/uniswap/getQuote.ts
async function getUniswapQuote(agent, fromToken, toToken, amount, fee = DEFAULT_POOL_FEE) {
  if (agent.demo) {
    return createMockQuoteResponse("Uniswap", amount);
  }
  return await getUniswapQuoteData(agent, fromToken, toToken, amount, fee);
}

// src/tools/uniswap/swap.ts
async function swapOnUniswap(agent, fromToken, toToken, amount, slippage = "0.5", fee = DEFAULT_POOL_FEE) {
  if (agent.demo) {
    return createMockUniswapSwapResponse(amount);
  }
  const walletAddress = agent.account.address;
  const isNativeIn = fromToken.toLowerCase() === NATIVE_TOKEN_ADDRESS2.toLowerCase();
  const quote = await getUniswapQuoteData(agent, fromToken, toToken, amount, fee);
  console.log(`Uniswap quote: ${quote.amountOut.toString()}`);
  const slippageBps = Math.floor(parseFloat(slippage) * 100);
  const amountOutMinimum = quote.amountOut * BigInt(1e4 - slippageBps) / BigInt(1e4);
  if (!isNativeIn) {
    await approveToken2(agent, fromToken, SWAP_ROUTER_ADDRESS, amount);
  }
  const calldata = buildSwapCalldata(
    {
      tokenIn: fromToken,
      tokenOut: toToken,
      amountIn: amount,
      amountOutMinimum: amountOutMinimum.toString(),
      recipient: walletAddress
    },
    fee
  );
  const gasEstimate = await agent.client.estimateGas({
    account: agent.account,
    to: SWAP_ROUTER_ADDRESS,
    data: calldata,
    value: isNativeIn ? BigInt(amount) : BigInt(0)
  });
  const txHash = await agent.client.sendTransaction({
    to: SWAP_ROUTER_ADDRESS,
    data: calldata,
    value: isNativeIn ? BigInt(amount) : BigInt(0),
    gas: gasEstimate
  });
  console.log(`Uniswap swap tx sent: ${txHash}`);
  const receipt = await agent.client.waitForTransactionReceipt({
    hash: txHash
  });
  console.log(`Swap confirmed: ${receipt.status}`);
  return {
    txHash,
    amountOut: quote.amountOut.toString()
  };
}

// src/constants/squid/index.ts
var squid_exports = {};
__export(squid_exports, {
  DESTINATION_CHAINS: () => DESTINATION_CHAINS,
  NATIVE_TOKEN_ADDRESS: () => NATIVE_TOKEN_ADDRESS3,
  SQUID_BASE_URL: () => SQUID_BASE_URL,
  SQUID_CHAIN_ID: () => SQUID_CHAIN_ID
});
var SQUID_BASE_URL = "https://api.squidrouter.com/v2";
var SQUID_CHAIN_ID = {
  mainnet: 5e3,
  // Mantle mainnet
  testnet: 5003
  // Mantle testnet
};
var DESTINATION_CHAINS = {
  ethereum: 101,
  arbitrum: 110,
  optimism: 111,
  polygon: 109,
  base: 184,
  bsc: 102,
  avalanche: 106,
  mantle: 5e3
};
var NATIVE_TOKEN_ADDRESS3 = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";

// src/helpers/squid/index.ts
function getHeaders3(integratorId) {
  const headers = {
    "Content-Type": "application/json"
  };
  return headers;
}

// src/utils/squid/getRouteData.ts
async function getRouteData(fromToken, toToken, fromChain, toChain, amount, fromAddress, slippage = 1) {
  const params = {
    fromChain: fromChain.toString(),
    toChain: toChain.toString(),
    fromToken: fromToken.toLowerCase() === NATIVE_TOKEN_ADDRESS3.toLowerCase() ? "native" : fromToken,
    toToken: toToken.toLowerCase() === NATIVE_TOKEN_ADDRESS3.toLowerCase() ? "native" : toToken,
    fromAmount: amount,
    fromAddress,
    slippage: slippage.toString(),
    enableForecast: false
  };
  const response = await axios__default.default.get(`${SQUID_BASE_URL}/route`, {
    params,
    headers: getHeaders3()
  });
  return response.data;
}

// src/tools/squid/crossChainSwap.ts
async function crossChainSwapViaSquid(agent, fromToken, toToken, fromChain, toChain, amount, slippage = 1) {
  if (agent.demo) {
    return createMockTxHash();
  }
  const routeData = await getRouteData(
    fromToken,
    toToken,
    fromChain,
    toChain,
    amount,
    agent.account.address,
    slippage
  );
  const transactionRequest = routeData.route.transactionRequest;
  if (fromToken.toLowerCase() !== NATIVE_TOKEN_ADDRESS3.toLowerCase() && transactionRequest.targetAddress) {
    await approveToken2(
      agent,
      fromToken,
      transactionRequest.targetAddress,
      amount
    );
  }
  const hash = await agent.client.sendTransaction({
    to: transactionRequest.targetAddress,
    data: transactionRequest.data,
    value: BigInt(transactionRequest.value || "0"),
    gas: BigInt(transactionRequest.gasLimit || "0")
  });
  await agent.client.waitForTransactionReceipt({ hash });
  return hash;
}
async function getSquidRoute(agent, fromToken, toToken, fromChain, toChain, amount, slippage = 1) {
  if (agent.demo) {
    return createMockSquidRoute(amount);
  }
  return await getRouteData(
    fromToken,
    toToken,
    fromChain,
    toChain,
    amount,
    agent.account.address,
    slippage
  );
}

// src/constants/lendle/index.ts
var lendle_exports = {};
__export(lendle_exports, {
  INTEREST_RATE_MODE: () => INTEREST_RATE_MODE,
  LENDING_POOL: () => LENDING_POOL,
  LENDING_POOL_ABI: () => LENDING_POOL_ABI,
  LENDING_POOL_ADDRESSES_PROVIDER: () => LENDING_POOL_ADDRESSES_PROVIDER,
  LENDLE_SUPPORTED_ASSETS: () => LENDLE_SUPPORTED_ASSETS,
  ORACLE: () => ORACLE,
  PROTOCOL_DATA_PROVIDER: () => PROTOCOL_DATA_PROVIDER,
  PROTOCOL_DATA_PROVIDER_ABI: () => PROTOCOL_DATA_PROVIDER_ABI,
  WMNT_ADDRESS: () => WMNT_ADDRESS2
});
var LENDING_POOL = {
  mainnet: "0xCFa5aE7c2CE8Fadc6426C1ff872cA45378Fb7cF3",
  testnet: "0x0000000000000000000000000000000000000000"
  // Not deployed on testnet
};
var LENDING_POOL_ADDRESSES_PROVIDER = {
  mainnet: "0xAb94Bedd21ae3411eB2698945dfCab1D5C19C3d4",
  testnet: "0x0000000000000000000000000000000000000000"
};
var PROTOCOL_DATA_PROVIDER = {
  mainnet: "0x552b9e4bae485C4B7F540777d7D25614CdB84773",
  testnet: "0x0000000000000000000000000000000000000000"
};
var ORACLE = {
  mainnet: "0x870c9692Ab04944C86ec6FEeF63F261226506EfC",
  testnet: "0x0000000000000000000000000000000000000000"
};
var WMNT_ADDRESS2 = "0x78c1b0C915c4FAA5FffA6CAbf0219DA63d7f4cb8";
var INTEREST_RATE_MODE = {
  STABLE: 1,
  VARIABLE: 2
};
var LENDING_POOL_ABI = [
  {
    inputs: [
      { name: "asset", type: "address" },
      { name: "amount", type: "uint256" },
      { name: "onBehalfOf", type: "address" },
      { name: "referralCode", type: "uint16" }
    ],
    name: "deposit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "asset", type: "address" },
      { name: "amount", type: "uint256" },
      { name: "to", type: "address" }
    ],
    name: "withdraw",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "asset", type: "address" },
      { name: "amount", type: "uint256" },
      { name: "interestRateMode", type: "uint256" },
      { name: "referralCode", type: "uint16" },
      { name: "onBehalfOf", type: "address" }
    ],
    name: "borrow",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "asset", type: "address" },
      { name: "amount", type: "uint256" },
      { name: "rateMode", type: "uint256" },
      { name: "onBehalfOf", type: "address" }
    ],
    name: "repay",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ name: "user", type: "address" }],
    name: "getUserAccountData",
    outputs: [
      { name: "totalCollateralETH", type: "uint256" },
      { name: "totalDebtETH", type: "uint256" },
      { name: "availableBorrowsETH", type: "uint256" },
      { name: "currentLiquidationThreshold", type: "uint256" },
      { name: "ltv", type: "uint256" },
      { name: "healthFactor", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "asset", type: "address" }],
    name: "getReserveData",
    outputs: [
      {
        components: [
          { name: "configuration", type: "uint256" },
          { name: "liquidityIndex", type: "uint128" },
          { name: "variableBorrowIndex", type: "uint128" },
          { name: "currentLiquidityRate", type: "uint128" },
          { name: "currentVariableBorrowRate", type: "uint128" },
          { name: "currentStableBorrowRate", type: "uint128" },
          { name: "lastUpdateTimestamp", type: "uint40" },
          { name: "aTokenAddress", type: "address" },
          { name: "stableDebtTokenAddress", type: "address" },
          { name: "variableDebtTokenAddress", type: "address" },
          { name: "interestRateStrategyAddress", type: "address" },
          { name: "id", type: "uint8" }
        ],
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var PROTOCOL_DATA_PROVIDER_ABI = [
  {
    inputs: [],
    name: "getAllReservesTokens",
    outputs: [
      {
        components: [
          { name: "symbol", type: "string" },
          { name: "tokenAddress", type: "address" }
        ],
        name: "",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "asset", type: "address" },
      { name: "user", type: "address" }
    ],
    name: "getUserReserveData",
    outputs: [
      { name: "currentATokenBalance", type: "uint256" },
      { name: "currentStableDebt", type: "uint256" },
      { name: "currentVariableDebt", type: "uint256" },
      { name: "principalStableDebt", type: "uint256" },
      { name: "scaledVariableDebt", type: "uint256" },
      { name: "stableBorrowRate", type: "uint256" },
      { name: "liquidityRate", type: "uint256" },
      { name: "stableRateLastUpdated", type: "uint40" },
      { name: "usageAsCollateralEnabled", type: "bool" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "asset", type: "address" }],
    name: "getReserveTokensAddresses",
    outputs: [
      { name: "aTokenAddress", type: "address" },
      { name: "stableDebtTokenAddress", type: "address" },
      { name: "variableDebtTokenAddress", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var LENDLE_SUPPORTED_ASSETS = {
  mainnet: [
    { symbol: "WMNT", address: "0x78c1b0C915c4FAA5FffA6CAbf0219DA63d7f4cb8" },
    { symbol: "WETH", address: "0xdEAddEaDdeadDEadDEADDEAddEADDEAddead1111" },
    { symbol: "USDC", address: "0x09Bc4E0D10C81b3a3766c49F0f98a8aaa7adA8D2" },
    { symbol: "USDT", address: "0x201EBa5CC46D216Ce6DC03F6a759e8E766e956aE" },
    { symbol: "mETH", address: "0xcDA86A272531e8640cD7F1a92c01839911B90bb0" }
  ],
  testnet: []
};

// src/tools/lendle/supply.ts
async function lendleSupply(agent, tokenAddress, amount) {
  const lendingPoolAddress = LENDING_POOL[agent.chain];
  if (lendingPoolAddress === "0x0000000000000000000000000000000000000000") {
    if (agent.demo) {
      return createMockLendleResponse("supply", amount).txHash;
    }
    throw new Error(
      `Lendle LendingPool not configured for ${agent.chain}. Only available on mainnet.`
    );
  }
  const amountBigInt = BigInt(amount);
  const isNative = tokenAddress.toLowerCase() === WMNT_ADDRESS2.toLowerCase();
  if (!isNative) {
    await approveToken2(agent, tokenAddress, lendingPoolAddress, amount);
  }
  const data = viem.encodeFunctionData({
    abi: LENDING_POOL_ABI,
    functionName: "deposit",
    args: [tokenAddress, amountBigInt, agent.account.address, 0]
    // referralCode = 0 (uint16)
  });
  const hash = await agent.client.sendTransaction({
    to: lendingPoolAddress,
    data,
    value: isNative ? amountBigInt : 0n
  });
  await agent.client.waitForTransactionReceipt({ hash });
  return hash;
}
async function lendleWithdraw(agent, tokenAddress, amount, to) {
  const lendingPoolAddress = LENDING_POOL[agent.chain];
  if (lendingPoolAddress === "0x0000000000000000000000000000000000000000") {
    if (agent.demo) {
      return createMockLendleResponse("withdraw", amount).txHash;
    }
    throw new Error(
      `Lendle LendingPool not configured for ${agent.chain}. Only available on mainnet.`
    );
  }
  const amountBigInt = BigInt(amount);
  const toAddress = to || agent.account.address;
  const data = viem.encodeFunctionData({
    abi: LENDING_POOL_ABI,
    functionName: "withdraw",
    args: [tokenAddress, amountBigInt, toAddress]
  });
  const hash = await agent.client.sendTransaction({
    to: lendingPoolAddress,
    data
  });
  await agent.client.waitForTransactionReceipt({ hash });
  return hash;
}
async function lendleBorrow(agent, tokenAddress, amount, interestRateMode = INTEREST_RATE_MODE.VARIABLE, onBehalfOf) {
  const lendingPoolAddress = LENDING_POOL[agent.chain];
  if (lendingPoolAddress === "0x0000000000000000000000000000000000000000") {
    if (agent.demo) {
      return createMockLendleResponse("borrow", amount).txHash;
    }
    throw new Error(
      `Lendle LendingPool not configured for ${agent.chain}. Only available on mainnet.`
    );
  }
  const amountBigInt = BigInt(amount);
  const onBehalfOfAddress = onBehalfOf || agent.account.address;
  const data = viem.encodeFunctionData({
    abi: LENDING_POOL_ABI,
    functionName: "borrow",
    args: [tokenAddress, amountBigInt, BigInt(interestRateMode), 0, onBehalfOfAddress]
    // referralCode = 0 (uint16)
  });
  const hash = await agent.client.sendTransaction({
    to: lendingPoolAddress,
    data
  });
  await agent.client.waitForTransactionReceipt({ hash });
  return hash;
}
async function lendleRepay(agent, tokenAddress, amount, rateMode = INTEREST_RATE_MODE.VARIABLE, onBehalfOf) {
  const lendingPoolAddress = LENDING_POOL[agent.chain];
  if (lendingPoolAddress === "0x0000000000000000000000000000000000000000") {
    if (agent.demo) {
      return createMockLendleResponse("repay", amount).txHash;
    }
    throw new Error(
      `Lendle LendingPool not configured for ${agent.chain}. Only available on mainnet.`
    );
  }
  const amountBigInt = BigInt(amount);
  const onBehalfOfAddress = onBehalfOf || agent.account.address;
  await approveToken2(agent, tokenAddress, lendingPoolAddress, amount);
  const data = viem.encodeFunctionData({
    abi: LENDING_POOL_ABI,
    functionName: "repay",
    args: [tokenAddress, amountBigInt, BigInt(rateMode), onBehalfOfAddress]
  });
  const hash = await agent.client.sendTransaction({
    to: lendingPoolAddress,
    data
  });
  await agent.client.waitForTransactionReceipt({ hash });
  return hash;
}
async function lendleGetPositions(agent, userAddress) {
  const dataProviderAddress = PROTOCOL_DATA_PROVIDER[agent.chain];
  const address = userAddress || agent.account.address;
  if (dataProviderAddress === "0x0000000000000000000000000000000000000000") {
    if (agent.demo) {
      return {
        positions: [
          {
            asset: "0x78c1b0C915c4FAA5FffA6CAbf0219DA63d7f4cb8",
            // WMNT
            symbol: "WMNT",
            supplied: BigInt("1000000000000000000"),
            // 1 WMNT
            stableDebt: 0n,
            variableDebt: BigInt("200000000000000000"),
            // 0.2 WMNT borrowed
            totalDebt: BigInt("200000000000000000"),
            liquidityRate: BigInt("25000000000000000000000000"),
            // ~2.5% APY (in ray)
            stableBorrowRate: 0n,
            usageAsCollateralEnabled: true
          },
          {
            asset: "0xdEAddEaDdeadDEadDEADDEAddEADDEAddead1111",
            // WETH
            symbol: "WETH",
            supplied: BigInt("500000000000000000"),
            // 0.5 WETH
            stableDebt: 0n,
            variableDebt: 0n,
            totalDebt: 0n,
            liquidityRate: BigInt("30000000000000000000000000"),
            // ~3% APY
            stableBorrowRate: 0n,
            usageAsCollateralEnabled: true
          }
        ],
        totalSupplied: BigInt("1500000000000000000"),
        totalDebt: BigInt("200000000000000000")
      };
    }
    throw new Error(
      `Lendle ProtocolDataProvider not configured for ${agent.chain}. Only available on mainnet.`
    );
  }
  const supportedAssets = LENDLE_SUPPORTED_ASSETS[agent.chain];
  if (!supportedAssets || supportedAssets.length === 0) {
    throw new Error(`No supported assets configured for ${agent.chain}`);
  }
  const positions = [];
  let totalSupplied = 0n;
  let totalDebt = 0n;
  for (const asset of supportedAssets) {
    try {
      const assetAddress = viem.getAddress(asset.address);
      const result = await agent.client.readContract({
        address: dataProviderAddress,
        abi: PROTOCOL_DATA_PROVIDER_ABI,
        functionName: "getUserReserveData",
        args: [assetAddress, address]
      });
      const [
        currentATokenBalance,
        currentStableDebt,
        currentVariableDebt,
        _principalStableDebt,
        _scaledVariableDebt,
        stableBorrowRate,
        liquidityRate,
        _stableRateLastUpdated,
        usageAsCollateralEnabled
      ] = result;
      if (currentATokenBalance > 0n || currentStableDebt > 0n || currentVariableDebt > 0n) {
        const assetTotalDebt = currentStableDebt + currentVariableDebt;
        positions.push({
          asset: assetAddress,
          symbol: asset.symbol,
          supplied: currentATokenBalance,
          stableDebt: currentStableDebt,
          variableDebt: currentVariableDebt,
          totalDebt: assetTotalDebt,
          liquidityRate,
          stableBorrowRate,
          usageAsCollateralEnabled
        });
        totalSupplied += currentATokenBalance;
        totalDebt += assetTotalDebt;
      }
    } catch (error) {
      console.warn(`Failed to get position for ${asset.symbol}:`, error);
    }
  }
  return {
    positions,
    totalSupplied,
    totalDebt
  };
}

// src/constants/agni/index.ts
var agni_exports = {};
__export(agni_exports, {
  FACTORY: () => FACTORY,
  FEE_TIERS: () => FEE_TIERS2,
  POSITION_MANAGER: () => POSITION_MANAGER,
  SWAP_ROUTER: () => SWAP_ROUTER,
  SWAP_ROUTER_ABI: () => SWAP_ROUTER_ABI,
  WMNT: () => WMNT
});
var FACTORY = {
  mainnet: "0x25780dc8Fc3cfBD75F33bFDAB65e969b603b2035",
  testnet: "0x0000000000000000000000000000000000000000"
};
var SWAP_ROUTER = {
  mainnet: "0x319B69888b0d11cEC22caA5034e25FfFBDc88421",
  testnet: "0x0000000000000000000000000000000000000000"
};
var POSITION_MANAGER = {
  mainnet: "0x218bf598d1453383e2f4aa7b14ffb9bfb102d637",
  testnet: "0x0000000000000000000000000000000000000000"
};
var WMNT = {
  mainnet: "0x78c1b0C915c4FAA5FffA6CAbf0219DA63d7f4cb8",
  testnet: "0x0000000000000000000000000000000000000000"
};
var SWAP_ROUTER_ABI = [
  {
    inputs: [
      {
        components: [
          { name: "tokenIn", type: "address" },
          { name: "tokenOut", type: "address" },
          { name: "fee", type: "uint24" },
          { name: "recipient", type: "address" },
          { name: "deadline", type: "uint256" },
          { name: "amountIn", type: "uint256" },
          { name: "amountOutMinimum", type: "uint256" },
          { name: "sqrtPriceLimitX96", type: "uint160" }
        ],
        name: "params",
        type: "tuple"
      }
    ],
    name: "exactInputSingle",
    outputs: [{ name: "amountOut", type: "uint256" }],
    stateMutability: "payable",
    type: "function"
  }
];
var FEE_TIERS2 = {
  LOWEST: 100,
  // 0.01%
  LOW: 500,
  // 0.05%
  MEDIUM: 3e3,
  // 0.3%
  HIGH: 1e4
  // 1%
};

// src/tools/agni/swap.ts
var NATIVE_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
function isNativeToken(address) {
  return address.toLowerCase() === NATIVE_ADDRESS.toLowerCase() || address === "0x0000000000000000000000000000000000000000";
}
async function agniSwap(agent, tokenIn, tokenOut, amountIn, slippagePercent = 0.5, feeTier = FEE_TIERS2.MEDIUM) {
  const swapRouterAddress = SWAP_ROUTER[agent.chain];
  if (swapRouterAddress === "0x0000000000000000000000000000000000000000") {
    if (agent.demo) {
      return createMockSwapResponse("Agni", amountIn).txHash;
    }
    throw new Error(`Agni SwapRouter not available on ${agent.chain}`);
  }
  const amountInBigInt = BigInt(amountIn);
  const deadline = BigInt(Math.floor(Date.now() / 1e3) + 1200);
  const amountOutMinimum = 0n;
  const isNativeIn = isNativeToken(tokenIn);
  const isNativeOut = isNativeToken(tokenOut);
  const wmntAddress = WMNT[agent.chain];
  const actualTokenIn = isNativeIn ? wmntAddress : tokenIn;
  const actualTokenOut = isNativeOut ? wmntAddress : tokenOut;
  if (!isNativeIn) {
    await approveToken2(agent, tokenIn, swapRouterAddress, amountIn);
  }
  const data = viem.encodeFunctionData({
    abi: SWAP_ROUTER_ABI,
    functionName: "exactInputSingle",
    args: [
      {
        tokenIn: actualTokenIn,
        tokenOut: actualTokenOut,
        fee: feeTier,
        recipient: agent.account.address,
        deadline,
        amountIn: amountInBigInt,
        amountOutMinimum,
        sqrtPriceLimitX96: 0n
      }
    ]
  });
  const hash = await agent.client.sendTransaction({
    to: swapRouterAddress,
    data,
    value: isNativeIn ? amountInBigInt : 0n
  });
  await agent.client.waitForTransactionReceipt({ hash });
  return hash;
}

// src/constants/merchantmoe/index.ts
var merchantmoe_exports = {};
__export(merchantmoe_exports, {
  DEFAULT_BIN_STEP: () => DEFAULT_BIN_STEP,
  LB_FACTORY: () => LB_FACTORY,
  LB_FACTORY_ABI: () => LB_FACTORY_ABI,
  LB_PAIR_ABI: () => LB_PAIR_ABI,
  LB_QUOTER: () => LB_QUOTER,
  LB_ROUTER: () => LB_ROUTER,
  LB_ROUTER_ABI: () => LB_ROUTER_ABI,
  LB_VERSION: () => LB_VERSION,
  MOE_TOKEN: () => MOE_TOKEN,
  WMNT: () => WMNT2
});
var LB_ROUTER = {
  mainnet: "0x013e138EF6008ae5FDFDE29700e3f2Bc61d21E3a",
  testnet: "0x0000000000000000000000000000000000000000"
};
var LB_FACTORY = {
  mainnet: "0xa6630671775c4EA2743840F9A5016dCf2A104054",
  testnet: "0x0000000000000000000000000000000000000000"
};
var LB_QUOTER = {
  mainnet: "0x501b8AFd35df20f531fF45F6f695793AC3316c85",
  testnet: "0x0000000000000000000000000000000000000000"
};
var WMNT2 = {
  mainnet: "0x78c1b0C915c4FAA5FffA6CAbf0219DA63d7f4cb8",
  testnet: "0x0000000000000000000000000000000000000000"
};
var MOE_TOKEN = "0x4515a45337f461a11ff0fe8abf3c606ae5dc00c9";
var LB_VERSION = {
  V1: 0,
  V2: 1,
  V2_1: 2,
  V2_2: 3
};
var DEFAULT_BIN_STEP = 15;
var LB_ROUTER_ABI = [
  {
    inputs: [
      { name: "amountOutMin", type: "uint256" },
      {
        name: "path",
        type: "tuple",
        components: [
          { name: "pairBinSteps", type: "uint256[]" },
          { name: "versions", type: "uint8[]" },
          { name: "tokenPath", type: "address[]" }
        ]
      },
      { name: "to", type: "address" },
      { name: "deadline", type: "uint256" }
    ],
    name: "swapExactNATIVEForTokens",
    outputs: [{ name: "amountOut", type: "uint256" }],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { name: "amountIn", type: "uint256" },
      { name: "amountOutMin", type: "uint256" },
      {
        name: "path",
        type: "tuple",
        components: [
          { name: "pairBinSteps", type: "uint256[]" },
          { name: "versions", type: "uint8[]" },
          { name: "tokenPath", type: "address[]" }
        ]
      },
      { name: "to", type: "address" },
      { name: "deadline", type: "uint256" }
    ],
    name: "swapExactTokensForTokens",
    outputs: [{ name: "amountOut", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "amountIn", type: "uint256" },
      { name: "amountOutMin", type: "uint256" },
      {
        name: "path",
        type: "tuple",
        components: [
          { name: "pairBinSteps", type: "uint256[]" },
          { name: "versions", type: "uint8[]" },
          { name: "tokenPath", type: "address[]" }
        ]
      },
      { name: "to", type: "address" },
      { name: "deadline", type: "uint256" }
    ],
    name: "swapExactTokensForNATIVE",
    outputs: [{ name: "amountOut", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  }
];
var LB_PAIR_ABI = [
  {
    inputs: [],
    name: "getTokenX",
    outputs: [{ name: "tokenX", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getTokenY",
    outputs: [{ name: "tokenY", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getReservesAndId",
    outputs: [
      { name: "reserveX", type: "uint128" },
      { name: "reserveY", type: "uint128" },
      { name: "activeId", type: "uint24" }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var LB_FACTORY_ABI = [
  {
    inputs: [
      { name: "tokenX", type: "address" },
      { name: "tokenY", type: "address" }
    ],
    name: "getAllLBPairs",
    outputs: [
      {
        name: "lbPairsAvailable",
        type: "tuple[]",
        components: [
          { name: "binStep", type: "uint16" },
          { name: "LBPair", type: "address" },
          { name: "createdByOwner", type: "bool" },
          { name: "ignoredForRouting", type: "bool" }
        ]
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// src/tools/merchantmoe/swap.ts
var NATIVE_ADDRESS2 = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
function isNativeToken2(address) {
  return address.toLowerCase() === NATIVE_ADDRESS2.toLowerCase() || address === "0x0000000000000000000000000000000000000000";
}
async function getAvailablePairs(agent, tokenA, tokenB) {
  const factoryAddress = LB_FACTORY[agent.chain];
  const pairs = await agent.client.readContract({
    address: factoryAddress,
    abi: LB_FACTORY_ABI,
    functionName: "getAllLBPairs",
    args: [tokenA, tokenB]
  });
  return pairs.map((p) => ({
    binStep: p.binStep,
    lbPair: p.LBPair,
    ignoredForRouting: p.ignoredForRouting
  }));
}
async function merchantMoeSwap(agent, tokenIn, tokenOut, amountIn, slippagePercent = 0.5, binStep) {
  const routerAddress = LB_ROUTER[agent.chain];
  if (routerAddress === "0x0000000000000000000000000000000000000000") {
    if (agent.demo) {
      return createMockSwapResponse("MerchantMoe", amountIn).txHash;
    }
    throw new Error(`Merchant Moe LB Router not available on ${agent.chain}`);
  }
  const amountInBigInt = BigInt(amountIn);
  const deadline = BigInt(Math.floor(Date.now() / 1e3) + 1200);
  const isNativeIn = isNativeToken2(tokenIn);
  const wmntAddress = WMNT2[agent.chain];
  const actualTokenIn = isNativeIn ? wmntAddress : tokenIn;
  let useBinStep = binStep;
  if (!useBinStep) {
    console.log("Looking for available liquidity pools...");
    const pairs = await getAvailablePairs(agent, actualTokenIn, tokenOut);
    console.log(`All pairs found:`, pairs);
    const validPairs = pairs.filter((p) => !p.ignoredForRouting);
    if (validPairs.length === 0) {
      throw new Error(`No liquidity pool found for ${actualTokenIn}/${tokenOut}. Try a different token pair.`);
    }
    const bestPair = validPairs[0];
    useBinStep = bestPair.binStep;
    console.log(`Using pool: ${bestPair.lbPair} with bin step: ${useBinStep}`);
  }
  const amountOutMin = 0n;
  const path = {
    pairBinSteps: [BigInt(useBinStep)],
    versions: [LB_VERSION.V2_1],
    tokenPath: isNativeIn ? [wmntAddress, tokenOut] : [tokenIn, tokenOut]
  };
  if (isNativeIn) {
    const data = viem.encodeFunctionData({
      abi: LB_ROUTER_ABI,
      functionName: "swapExactNATIVEForTokens",
      args: [amountOutMin, path, agent.account.address, deadline]
    });
    const hash = await agent.client.sendTransaction({
      to: routerAddress,
      data,
      value: amountInBigInt
    });
    await agent.client.waitForTransactionReceipt({ hash });
    return hash;
  } else {
    await approveToken2(agent, tokenIn, routerAddress, amountIn);
    const data = viem.encodeFunctionData({
      abi: LB_ROUTER_ABI,
      functionName: "swapExactTokensForTokens",
      args: [amountInBigInt, amountOutMin, path, agent.account.address, deadline]
    });
    const hash = await agent.client.sendTransaction({
      to: routerAddress,
      data
    });
    await agent.client.waitForTransactionReceipt({ hash });
    return hash;
  }
}

// src/constants/meth/index.ts
var meth_exports = {};
__export(meth_exports, {
  METH_ABI: () => METH_ABI,
  METH_TOKEN: () => METH_TOKEN,
  NATIVE_MNT_ADDRESS: () => NATIVE_MNT_ADDRESS,
  WETH_TOKEN: () => WETH_TOKEN,
  WMNT_TOKEN: () => WMNT_TOKEN
});
var METH_TOKEN = {
  mainnet: "0xcDA86A272531e8640cD7F1a92c01839911B90bb0",
  testnet: "0x0000000000000000000000000000000000000000"
};
var WETH_TOKEN = {
  mainnet: "0xdEAddEaDdeadDEadDEADDEAddEADDEAddead1111",
  testnet: "0xdEAddEaDdeadDEadDEADDEAddEADDEAddead1111"
};
var WMNT_TOKEN = {
  mainnet: "0x78c1b0C915c4FAA5FffA6CAbf0219DA63d7f4cb8",
  testnet: "0x78c1b0C915c4FAA5FffA6CAbf0219DA63d7f4cb8"
};
var NATIVE_MNT_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
var METH_ABI = [
  {
    inputs: [{ name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [{ name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "spender", type: "address" },
      { name: "amount", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "owner", type: "address" },
      { name: "spender", type: "address" }
    ],
    name: "allowance",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  }
];
async function methGetPosition(agent, userAddress) {
  const methTokenAddress = METH_TOKEN[agent.chain];
  const wethTokenAddress = WETH_TOKEN[agent.chain];
  const wmntTokenAddress = WMNT_TOKEN[agent.chain];
  const address = userAddress || agent.account.address;
  if (methTokenAddress === "0x0000000000000000000000000000000000000000") {
    if (agent.demo) {
      return {
        methBalance: BigInt("2500000000000000000"),
        // 2.5 mETH
        wethBalance: BigInt("1000000000000000000"),
        // 1 WETH
        wmntBalance: BigInt("5000000000000000000000"),
        // 5000 WMNT
        methTokenAddress,
        wethTokenAddress,
        wmntTokenAddress
      };
    }
    throw new Error(
      `mETH not available on ${agent.chain}. Only available on mainnet.`
    );
  }
  const methBalance = await agent.client.readContract({
    address: methTokenAddress,
    abi: METH_ABI,
    functionName: "balanceOf",
    args: [address]
  });
  let wethBalance = 0n;
  try {
    wethBalance = await agent.client.readContract({
      address: wethTokenAddress,
      abi: METH_ABI,
      // Same ERC20 ABI works for WETH
      functionName: "balanceOf",
      args: [address]
    });
  } catch {
  }
  let wmntBalance = 0n;
  try {
    wmntBalance = await agent.client.readContract({
      address: wmntTokenAddress,
      abi: METH_ABI,
      // Same ERC20 ABI works for WMNT
      functionName: "balanceOf",
      args: [address]
    });
  } catch {
  }
  return {
    methBalance,
    wethBalance,
    wmntBalance,
    methTokenAddress,
    wethTokenAddress,
    wmntTokenAddress
  };
}
async function swapToMeth(agent, amount, slippage = 0.5) {
  const methTokenAddress = METH_TOKEN[agent.chain];
  const wethTokenAddress = WETH_TOKEN[agent.chain];
  if (methTokenAddress === "0x0000000000000000000000000000000000000000") {
    if (agent.demo) {
      return "0xdemo000000000000000000000000000000000000000000000000000000000001";
    }
    throw new Error(
      `mETH not available on ${agent.chain}. Only available on mainnet.`
    );
  }
  const result = await swapOnOpenOcean(
    agent,
    wethTokenAddress,
    methTokenAddress,
    amount,
    slippage.toString()
  );
  return result.txHash;
}
async function swapFromMeth(agent, amount, slippage = 0.5) {
  const methTokenAddress = METH_TOKEN[agent.chain];
  const wethTokenAddress = WETH_TOKEN[agent.chain];
  if (methTokenAddress === "0x0000000000000000000000000000000000000000") {
    if (agent.demo) {
      return "0xdemo000000000000000000000000000000000000000000000000000000000001";
    }
    throw new Error(
      `mETH not available on ${agent.chain}. Only available on mainnet.`
    );
  }
  const result = await swapOnOpenOcean(
    agent,
    methTokenAddress,
    wethTokenAddress,
    amount,
    slippage.toString()
  );
  return result.txHash;
}

// src/constants/pikeperps/index.ts
var pikeperps_exports = {};
__export(pikeperps_exports, {
  BONDING_CURVE_MARKET: () => BONDING_CURVE_MARKET,
  BONDING_CURVE_MARKET_ABI: () => BONDING_CURVE_MARKET_ABI,
  PERPETUAL_TRADING: () => PERPETUAL_TRADING,
  PERPETUAL_TRADING_ABI: () => PERPETUAL_TRADING_ABI,
  PIKE_PERPS_CONFIG: () => PIKE_PERPS_CONFIG
});
var PERPETUAL_TRADING = {
  mainnet: "0x0000000000000000000000000000000000000000",
  // Not deployed yet
  testnet: "0x8081b646f349c049f2d5e8a400057d411dd657bd"
};
var BONDING_CURVE_MARKET = {
  mainnet: "0x0000000000000000000000000000000000000000",
  testnet: "0x93b268325A9862645c82b32229f3B52264750Ca2"
};
var PIKE_PERPS_CONFIG = {
  MAX_LEVERAGE: 100,
  DEFAULT_LEVERAGE: 10,
  MIN_LEVERAGE: 1,
  TRADING_FEE_BPS: 5,
  // 0.05%
  LIQUIDATION_REWARD_BPS: 500,
  // 5%
  PRICE_DECIMALS: 8
  // Prices are scaled by 1e8
};
var PERPETUAL_TRADING_ABI = [
  {
    inputs: [
      { internalType: "address", name: "_pyth", type: "address" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "uint256", name: "positionId", type: "uint256" },
      { indexed: true, internalType: "address", name: "user", type: "address" },
      { indexed: false, internalType: "uint256", name: "pnl", type: "uint256" },
      { indexed: false, internalType: "uint256", name: "exitPrice", type: "uint256" }
    ],
    name: "PositionClosed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "uint256", name: "positionId", type: "uint256" },
      { indexed: true, internalType: "address", name: "user", type: "address" },
      { indexed: false, internalType: "uint256", name: "liquidationPrice", type: "uint256" }
    ],
    name: "PositionLiquidated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "uint256", name: "positionId", type: "uint256" },
      { indexed: true, internalType: "address", name: "user", type: "address" },
      { indexed: true, internalType: "address", name: "token", type: "address" },
      { indexed: false, internalType: "bool", name: "isLong", type: "bool" },
      { indexed: false, internalType: "uint256", name: "size", type: "uint256" },
      { indexed: false, internalType: "uint256", name: "margin", type: "uint256" },
      { indexed: false, internalType: "uint256", name: "leverage", type: "uint256" },
      { indexed: false, internalType: "uint256", name: "entryPrice", type: "uint256" }
    ],
    name: "PositionOpened",
    type: "event"
  },
  {
    inputs: [{ internalType: "uint256", name: "_positionId", type: "uint256" }],
    name: "closePosition",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "_token", type: "address" }],
    name: "getCurrentPrice",
    outputs: [
      { internalType: "uint256", name: "currentPrice", type: "uint256" },
      { internalType: "bool", name: "hasPrice", type: "bool" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "_positionId", type: "uint256" }],
    name: "getLiquidationPrice",
    outputs: [{ internalType: "uint256", name: "liquidationPrice", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "_positionId", type: "uint256" }],
    name: "getPosition",
    outputs: [
      {
        components: [
          { internalType: "address", name: "user", type: "address" },
          { internalType: "address", name: "token", type: "address" },
          { internalType: "bool", name: "isLong", type: "bool" },
          { internalType: "uint256", name: "size", type: "uint256" },
          { internalType: "uint256", name: "margin", type: "uint256" },
          { internalType: "uint256", name: "leverage", type: "uint256" },
          { internalType: "uint256", name: "entryPrice", type: "uint256" },
          { internalType: "uint256", name: "entryTime", type: "uint256" },
          { internalType: "uint256", name: "lastFundingTime", type: "uint256" },
          { internalType: "bool", name: "isOpen", type: "bool" }
        ],
        internalType: "struct PerpetualTrading.Position",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "_positionId", type: "uint256" }],
    name: "getPositionPnL",
    outputs: [
      { internalType: "uint256", name: "pnl", type: "uint256" },
      { internalType: "bool", name: "isProfit", type: "bool" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "_user", type: "address" }],
    name: "getUserPositions",
    outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "_positionId", type: "uint256" }],
    name: "liquidatePosition",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "maxLeverage",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "minMarginBps",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "nextPositionId",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "_token", type: "address" },
      { internalType: "bool", name: "_isLong", type: "bool" },
      { internalType: "uint256", name: "_margin", type: "uint256" },
      { internalType: "uint256", name: "_leverage", type: "uint256" }
    ],
    name: "openPosition",
    outputs: [{ internalType: "uint256", name: "positionId", type: "uint256" }],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "_positionId", type: "uint256" }],
    name: "shouldLiquidate",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "tradingFeeBps",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  }
];
var BONDING_CURVE_MARKET_ABI = [
  {
    inputs: [{ internalType: "address", name: "_token", type: "address" }],
    name: "getCurrentPrice",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "_token", type: "address" }],
    name: "isListed",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "_token", type: "address" }],
    name: "getCurveProgress",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  }
];

// src/tools/pikeperps/openLong.ts
async function pikeperpsOpenLong(agent, tokenAddress, margin, leverage = PIKE_PERPS_CONFIG.DEFAULT_LEVERAGE) {
  const perpetualTradingAddress = PERPETUAL_TRADING[agent.chain];
  if (perpetualTradingAddress === "0x0000000000000000000000000000000000000000") {
    if (agent.demo) {
      return {
        positionId: BigInt(Math.floor(Math.random() * 1e3)),
        txHash: "0xdemo_open_long_tx_hash"
      };
    }
    throw new Error(
      `PikePerps not available on ${agent.chain}. Only available on testnet.`
    );
  }
  if (leverage < PIKE_PERPS_CONFIG.MIN_LEVERAGE || leverage > PIKE_PERPS_CONFIG.MAX_LEVERAGE) {
    throw new Error(
      `Leverage must be between ${PIKE_PERPS_CONFIG.MIN_LEVERAGE} and ${PIKE_PERPS_CONFIG.MAX_LEVERAGE}`
    );
  }
  const marginBigInt = BigInt(margin);
  const data = viem.encodeFunctionData({
    abi: PERPETUAL_TRADING_ABI,
    functionName: "openPosition",
    args: [tokenAddress, true, marginBigInt, BigInt(leverage)]
  });
  const txHash = await agent.client.sendTransaction({
    to: perpetualTradingAddress,
    data,
    value: marginBigInt
  });
  const receipt = await agent.client.waitForTransactionReceipt({ hash: txHash });
  let positionId = 0n;
  for (const log of receipt.logs) {
    try {
      if (log.topics[0] === "0x2e5b0e8c5f5d55d89e89f5b5d5e5f5d55d89e89f5b5d5e5f5d55d89e89f5b5d5") {
        positionId = BigInt(log.topics[1] || "0");
        break;
      }
    } catch {
    }
  }
  if (positionId === 0n) {
    try {
      const nextId = await agent.client.readContract({
        address: perpetualTradingAddress,
        abi: PERPETUAL_TRADING_ABI,
        functionName: "nextPositionId"
      });
      positionId = nextId - 1n;
    } catch {
    }
  }
  return {
    positionId,
    txHash
  };
}
async function pikeperpsOpenShort(agent, tokenAddress, margin, leverage = PIKE_PERPS_CONFIG.DEFAULT_LEVERAGE) {
  const perpetualTradingAddress = PERPETUAL_TRADING[agent.chain];
  if (perpetualTradingAddress === "0x0000000000000000000000000000000000000000") {
    if (agent.demo) {
      return {
        positionId: BigInt(Math.floor(Math.random() * 1e3)),
        txHash: "0xdemo_open_short_tx_hash"
      };
    }
    throw new Error(
      `PikePerps not available on ${agent.chain}. Only available on testnet.`
    );
  }
  if (leverage < PIKE_PERPS_CONFIG.MIN_LEVERAGE || leverage > PIKE_PERPS_CONFIG.MAX_LEVERAGE) {
    throw new Error(
      `Leverage must be between ${PIKE_PERPS_CONFIG.MIN_LEVERAGE} and ${PIKE_PERPS_CONFIG.MAX_LEVERAGE}`
    );
  }
  const marginBigInt = BigInt(margin);
  const data = viem.encodeFunctionData({
    abi: PERPETUAL_TRADING_ABI,
    functionName: "openPosition",
    args: [tokenAddress, false, marginBigInt, BigInt(leverage)]
  });
  const txHash = await agent.client.sendTransaction({
    to: perpetualTradingAddress,
    data,
    value: marginBigInt
  });
  const receipt = await agent.client.waitForTransactionReceipt({ hash: txHash });
  let positionId = 0n;
  for (const log of receipt.logs) {
    try {
      if (log.topics[0] === "0x2e5b0e8c5f5d55d89e89f5b5d5e5f5d55d89e89f5b5d5e5f5d55d89e89f5b5d5") {
        positionId = BigInt(log.topics[1] || "0");
        break;
      }
    } catch {
    }
  }
  if (positionId === 0n) {
    try {
      const nextId = await agent.client.readContract({
        address: perpetualTradingAddress,
        abi: PERPETUAL_TRADING_ABI,
        functionName: "nextPositionId"
      });
      positionId = nextId - 1n;
    } catch {
    }
  }
  return {
    positionId,
    txHash
  };
}
async function pikeperpsClosePosition(agent, positionId) {
  const perpetualTradingAddress = PERPETUAL_TRADING[agent.chain];
  if (perpetualTradingAddress === "0x0000000000000000000000000000000000000000") {
    if (agent.demo) {
      return "0xdemo_close_position_tx_hash";
    }
    throw new Error(
      `PikePerps not available on ${agent.chain}. Only available on testnet.`
    );
  }
  const data = viem.encodeFunctionData({
    abi: PERPETUAL_TRADING_ABI,
    functionName: "closePosition",
    args: [positionId]
  });
  const txHash = await agent.client.sendTransaction({
    to: perpetualTradingAddress,
    data
  });
  await agent.client.waitForTransactionReceipt({ hash: txHash });
  return txHash;
}
async function pikeperpsGetPositions(agent, userAddress) {
  const perpetualTradingAddress = PERPETUAL_TRADING[agent.chain];
  const address = userAddress || agent.account.address;
  if (perpetualTradingAddress === "0x0000000000000000000000000000000000000000") {
    if (agent.demo) {
      return [
        {
          positionId: 1n,
          token: "0x0000000000000000000000000000000000000001",
          isLong: true,
          size: BigInt("1000000000000000000"),
          // 1 ETH equivalent
          margin: BigInt("100000000000000000"),
          // 0.1 ETH
          leverage: 10,
          entryPrice: BigInt("100000000"),
          // $1.00 scaled by 1e8
          entryTime: BigInt(Math.floor(Date.now() / 1e3) - 3600),
          currentPrice: BigInt("110000000"),
          // $1.10
          pnl: BigInt("10000000000000000"),
          // 0.01 ETH profit
          isProfit: true,
          liquidationPrice: BigInt("90000000"),
          // $0.90
          isOpen: true
        }
      ];
    }
    throw new Error(
      `PikePerps not available on ${agent.chain}. Only available on testnet.`
    );
  }
  const positionIds = await agent.client.readContract({
    address: perpetualTradingAddress,
    abi: PERPETUAL_TRADING_ABI,
    functionName: "getUserPositions",
    args: [address]
  });
  if (positionIds.length === 0) {
    return [];
  }
  const positions = [];
  for (const positionId of positionIds) {
    try {
      const rawPosition = await agent.client.readContract({
        address: perpetualTradingAddress,
        abi: PERPETUAL_TRADING_ABI,
        functionName: "getPosition",
        args: [positionId]
      });
      if (!rawPosition.isOpen) {
        continue;
      }
      const [pnl, isProfit] = await agent.client.readContract({
        address: perpetualTradingAddress,
        abi: PERPETUAL_TRADING_ABI,
        functionName: "getPositionPnL",
        args: [positionId]
      });
      const liquidationPrice = await agent.client.readContract({
        address: perpetualTradingAddress,
        abi: PERPETUAL_TRADING_ABI,
        functionName: "getLiquidationPrice",
        args: [positionId]
      });
      let currentPrice = 0n;
      try {
        const [price, hasPrice] = await agent.client.readContract({
          address: perpetualTradingAddress,
          abi: PERPETUAL_TRADING_ABI,
          functionName: "getCurrentPrice",
          args: [rawPosition.token]
        });
        if (hasPrice) {
          currentPrice = price;
        }
      } catch {
        currentPrice = rawPosition.entryPrice;
      }
      positions.push({
        positionId,
        token: rawPosition.token,
        isLong: rawPosition.isLong,
        size: rawPosition.size,
        margin: rawPosition.margin,
        leverage: Number(rawPosition.leverage),
        entryPrice: rawPosition.entryPrice,
        entryTime: rawPosition.entryTime,
        currentPrice,
        pnl,
        isProfit,
        liquidationPrice,
        isOpen: rawPosition.isOpen
      });
    } catch (error) {
      console.warn(`Failed to fetch position ${positionId}:`, error);
    }
  }
  return positions;
}
async function pikeperpsGetMarketData(agent, tokenAddress, limit = 20) {
  const perpetualTradingAddress = PERPETUAL_TRADING[agent.chain];
  const bondingCurveAddress = BONDING_CURVE_MARKET[agent.chain];
  if (perpetualTradingAddress === "0x0000000000000000000000000000000000000000") {
    if (agent.demo) {
      return {
        token: tokenAddress,
        currentPrice: BigInt("100000000"),
        // $1.00 scaled by 1e8
        hasPrice: true,
        isListed: true,
        curveProgress: BigInt("5000"),
        // 50%
        recentTrades: [
          {
            positionId: 1n,
            trader: "0x0000000000000000000000000000000000000001",
            token: tokenAddress,
            isLong: true,
            size: BigInt("1000000000000000000"),
            margin: BigInt("100000000000000000"),
            leverage: 10n,
            entryPrice: BigInt("100000000"),
            timestamp: Math.floor(Date.now() / 1e3) - 300,
            txHash: "0xdemo_trade_hash",
            blockNumber: 1000n
          }
        ]
      };
    }
    throw new Error(
      `PikePerps not available on ${agent.chain}. Only available on testnet.`
    );
  }
  let currentPrice = 0n;
  let hasPrice = false;
  try {
    const [price, hasPriceResult] = await agent.client.readContract({
      address: perpetualTradingAddress,
      abi: PERPETUAL_TRADING_ABI,
      functionName: "getCurrentPrice",
      args: [tokenAddress]
    });
    currentPrice = price;
    hasPrice = hasPriceResult;
  } catch {
  }
  let isListed = false;
  let curveProgress = 0n;
  if (bondingCurveAddress !== "0x0000000000000000000000000000000000000000") {
    try {
      isListed = await agent.client.readContract({
        address: bondingCurveAddress,
        abi: BONDING_CURVE_MARKET_ABI,
        functionName: "isListed",
        args: [tokenAddress]
      });
      if (isListed) {
        curveProgress = await agent.client.readContract({
          address: bondingCurveAddress,
          abi: BONDING_CURVE_MARKET_ABI,
          functionName: "getCurveProgress",
          args: [tokenAddress]
        });
      }
    } catch {
    }
  }
  const recentTrades = [];
  try {
    const currentBlock = await agent.client.getBlockNumber();
    const fromBlock = currentBlock > 1000n ? currentBlock - 1000n : 0n;
    const logs = await agent.client.getLogs({
      address: perpetualTradingAddress,
      event: viem.parseAbiItem(
        "event PositionOpened(uint256 indexed positionId, address indexed user, address indexed token, bool isLong, uint256 size, uint256 margin, uint256 leverage, uint256 entryPrice)"
      ),
      args: {
        token: tokenAddress
      },
      fromBlock,
      toBlock: currentBlock
    });
    const blockCache = /* @__PURE__ */ new Map();
    for (const log of logs.slice(-limit)) {
      let timestamp = 0;
      if (!blockCache.has(log.blockNumber)) {
        try {
          const block = await agent.client.getBlock({
            blockNumber: log.blockNumber
          });
          timestamp = Number(block.timestamp);
          blockCache.set(log.blockNumber, timestamp);
        } catch {
          timestamp = Math.floor(Date.now() / 1e3);
        }
      } else {
        timestamp = blockCache.get(log.blockNumber) || 0;
      }
      recentTrades.push({
        positionId: BigInt(log.topics[1] || "0"),
        trader: log.topics[2],
        token: tokenAddress,
        isLong: log.args.isLong || false,
        size: log.args.size || 0n,
        margin: log.args.margin || 0n,
        leverage: log.args.leverage || 0n,
        entryPrice: log.args.entryPrice || 0n,
        timestamp,
        txHash: log.transactionHash,
        blockNumber: log.blockNumber
      });
    }
  } catch (error) {
    console.warn("Failed to fetch recent trades:", error);
  }
  return {
    token: tokenAddress,
    currentPrice,
    hasPrice,
    isListed,
    curveProgress,
    recentTrades
  };
}

// src/constants/pyth/index.ts
var pyth_exports = {};
__export(pyth_exports, {
  HERMES_ENDPOINT: () => HERMES_ENDPOINT,
  PYTH_ABI: () => PYTH_ABI,
  PYTH_CONTRACT: () => PYTH_CONTRACT,
  PYTH_PRICE_FEED_IDS: () => PYTH_PRICE_FEED_IDS,
  TOKEN_ADDRESS_TO_PRICE_FEED: () => TOKEN_ADDRESS_TO_PRICE_FEED,
  isTokenAddress: () => isTokenAddress,
  resolvePriceFeedInput: () => resolvePriceFeedInput
});
var PYTH_CONTRACT = {
  mainnet: "0xA2aa501b19aff244D90cc15a4Cf739D2725B5729",
  testnet: "0x98046Bd286715D3B0BC227Dd7a956b83D8978603"
};
var HERMES_ENDPOINT = {
  mainnet: "https://hermes.pyth.network",
  testnet: "https://hermes.pyth.network"
};
var PYTH_PRICE_FEED_IDS = {
  // === Major Cryptocurrencies ===
  "BTC/USD": "e62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43",
  "ETH/USD": "ff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace",
  "SOL/USD": "ef0d8b6fda2ceba41da15d4095d1da392a0d2f8ed0c6c7bc0f4cfac8c280b56d",
  "BNB/USD": "2f95862b045670cd22bee3114c39763a4a08beeb663b145d283c31d7d1101c4f",
  "XRP/USD": "ec5d399846a9209f3fe5881d70aae9268c94339ff9817e8d18ff19fa05eea1c8",
  "ADA/USD": "2a01deaec9e51a579277b34b122399984d0bbf57e2458a7e42fecd2829867a0d",
  "DOGE/USD": "dcef50dd0a4cd2dcc17e45df1676dcb336a11a61c69df7a0299b0150c672d25c",
  "DOT/USD": "ca3eed9b267293f6595901c734c7525ce8ef49adafe8284571c8e17d6c926346",
  "AVAX/USD": "93da3352f9f1d105fdfe4971cfa80e9dd777bfc5d0f683ebb6e1294b92137bb7",
  "MATIC/USD": "5de33440f6b7d0d7d70f0a7b2a6c0e0b8e5d2f7c8a9b0c1d2e3f4a5b6c7d8e9f",
  "LINK/USD": "8ac0c70fff57e9aefdf5edf44b51d62c2d433653cbb2cf5cc06bb115af04d221",
  "ATOM/USD": "b00b60f88b03a6a625a8d1c048c3f66653edf217439cb6a1cbab0c1c5e8c52bd",
  "LTC/USD": "6e3f3fa8253588df9326580180233eb791e03b443a3ba7a1d892e73874e19a54",
  "UNI/USD": "78d185a741d07edb3412b09008b7c5cfb9bbbd7d568bf00ba737b456ba171501",
  "NEAR/USD": "c415de8d2eba7db216527dff4b60e8f3a5311c740dadb233e13e12547e226750",
  "TRX/USD": "67aed5a24fdad045475e7195c98a98aea119c763f272d4523f5bac93a4f33c2b",
  // === Layer 2 & Scaling ===
  "ARB/USD": "3fa4252848f9f0a1480be62745a4629d9eb1322aebab8a791e344b3b9c1adcf5",
  "OP/USD": "385f64d993f7b77d8182ed5003d97c60aa3361f3cecfe711544d2d59165e9bdf",
  "MNT/USD": "4e3037c822d852d79af3ac80e35eb420ee3b870dca49f9344a38ef4773fb0585",
  "IMX/USD": "941320a8989414a6d2c757c8c6c52b3e7e0b7e4e4c5bb8a3c8e7a0f3e0f0f0f0",
  "STRK/USD": "6a182399ff70ccf3e06024898942028204125a819e519a335ffa4579e66cd870",
  // === DeFi Tokens ===
  "AAVE/USD": "2b9ab1e972a281585084148ba1389800799bd4be63b957507db1349314e47445",
  "CRV/USD": "a19d04ac696c7a6616d291c7e5d1377cc8be437c327b75adb5dc1bad745fcae8",
  "MKR/USD": "9375299e31c0deb9c6bc378e6329aab44cb48ec655552a70d4b9050346a30378",
  "SNX/USD": "39d020f60982ed892abbcd4a06a276a9f9b7bfbce003204c110b6e488f502da3",
  "COMP/USD": "4a8e42861cabc5ecb50996f92e7cfa2bce3fd0a2423b0c44c9b423fb2bd25478",
  "LDO/USD": "c63e2a7f37a04e5e614c07238bedb25dcc38927e77a90a4b21a7a2e1d7f0d2e3",
  "1INCH/USD": "63f341689d98a12ef60a5cff1d7f85c70a9e17bf1575f0e7c0b2512d48b1c8b3",
  "SUSHI/USD": "26e4f737fde0263a9eea10ae63ac36dcedab2aaf629f1e31a28a28dd0e0d2b0c",
  "YFI/USD": "425f4b198ab2504936886c1e93511bb6720fbcf2045a4f3c0723bb213846022f",
  "BAL/USD": "07ad7b4a7662d19a6bc675f6b467172d2f3947fa653ca97555a9b20236406628",
  "CAKE/USD": "2356af9529a1064d1d2a2e3e4ab6d6e6f6e6f6e6f6e6f6e6f6e6f6e6f6e6f6e6",
  "GMX/USD": "b962539d0fcb272a494d65ea56f94851c2bcf8823935da05bd628916e2e9edbf",
  "PENDLE/USD": "9a4df90b25497f66b1afb012467e316e801ca3d839456db028892fe8c70c8016",
  "JOE/USD": "1e8a156c8a23c1e56f2d9d7f0e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e",
  // === Stablecoins ===
  "USDC/USD": "eaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a",
  "USDT/USD": "2b89b9dc8fdf9f34709a5b106b472f0f39bb6ca9ce04b0fd7f2e971688e2e53b",
  "DAI/USD": "b0948a5e5313200c632b51bb5ca32f6de0d36e9950a942d19751e833f70dabfd",
  "FRAX/USD": "c3d5d8d6d0c0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0",
  "BUSD/USD": "5bc91f13e412c07599167bae86f07543f076a638962b8d6017ec19dab4a82814",
  "TUSD/USD": "433faaa801ecda2c0bbfa8f4e2d85fd4c310e2c1e5f8f8e6e5f5f5f5f5f5f5f5",
  "LUSD/USD": "d892ae586f4e0fbeee4d64f29ed6e89b1b3e2e2e2e2e2e2e2e2e2e2e2e2e2e2e",
  // === Wrapped & LST Tokens ===
  "WETH/USD": "ff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace",
  "WBTC/USD": "c9d8b075a5c69303365ae23633d4e085199bf5c520a3b90fed1322a0342ffc33",
  "stETH/USD": "846ae1bdb6300b817cee5fdee2a6da192775030db5615b94a465f53bd40850b5",
  "cbETH/USD": "15ecddd26d49e1a8f1de9376ebebc03916ede873447c1255d2d5891b92ce5717",
  "rETH/USD": "a0255134973f4fdf2f8f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f",
  "mETH/USD": "4c9c6f9f0cde13fced52dc1927c8c06a91b1a65ab77b9e1ec1c614963ce90dd4",
  "wstETH/USD": "6df640f3b8963d8f8358f791f352b8364513f6ab1cca5ed3f1f7b5448980e784",
  // === Meme Coins ===
  "SHIB/USD": "f0d57deca57b3da2fe63a493f4c25925fdfd8edf834b20f93e1f84dbd1504d4a",
  "PEPE/USD": "d69731a2e74ac1ce884fc3890f7ee324b6deb66147055249568869ed700882e4",
  "FLOKI/USD": "6b1381ce7e874dc5410b197ac8348162c0dd6c0d4c9cd6322c28a6f7f4d1a2d2",
  "BONK/USD": "72b021217ca3fe68922a19aaf990109cb9d84e9ad004b4d2025ad6f529314419",
  "WIF/USD": "4ca4beeca86f0d164160323817a4e42b10010a724c2217c6ee41b54cd4cc61fc",
  // === Gaming & Metaverse ===
  "AXS/USD": "b0d8f5e3f3a7c0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0",
  "SAND/USD": "f4040ec3e5b71c241a7e1a9a1e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e",
  "MANA/USD": "2b15e4bded7f5e5d5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
  "GALA/USD": "e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3",
  "APE/USD": "15add95022ae13563a11992e727c91bdb6b55bc183d9d747436c80a483d8c864",
  "ENJ/USD": "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
  // === Infrastructure & Oracles ===
  "FIL/USD": "150ac9b959aee0051e4091f0ef5216d941f590e1c5e7f91cf7635b5c11628c0e",
  "GRT/USD": "4d1f8dae0d96236fb98e8f47571a70f41c8b8f2f6d6c0e0e0e0e0e0e0e0e0e0e",
  "RNDR/USD": "ab7347771135fc733f8f38db462ba085ed3309955f42554a14fa13e855ac0e2f",
  "INJ/USD": "7a5bc1d2b56ad029048cd63964b3ad2776eadf812edc1a43a31406cb54bff592",
  "AR/USD": "8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c",
  "THETA/USD": "4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a",
  "PYTH/USD": "0bbf28e9a841a1cc788f6a361b17ca072d0ea3098a1e5df1c3922d06719579ff",
  // === AI & Data ===
  "FET/USD": "b49ee9d8ccf9b6e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0",
  "OCEAN/USD": "2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d",
  "TAO/USD": "410f41de235f2dbdf41f1a808c1e15f6a9e7d6a7b8c9d0e1f2a3b4c5d6e7f8a9",
  // === Exchange Tokens ===
  "FTT/USD": "6c75e52531ec5fd3ef253f6062956a8508a2f03fa0a209fb7dbc0d0f3d6f6f6f",
  "CRO/USD": "b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7",
  "OKB/USD": "23d7315113f5b1d3ba7a83604c44b94d79f4fd69af77f804fc7f920a6dc65744",
  // === Forex Pairs ===
  "EUR/USD": "a995d00bb36a63cef7fd2c287dc105fc8f3d93779f062f09551b0af3e81ec30b",
  "GBP/USD": "84c2dde9633d93d1bcad84e7dc41c9d56578b7ec52fabedc1f335d673df0a7c1",
  "JPY/USD": "ef2c98c804ba503c6a707e38be4dfbb16683775f195b091252bf24693042fd52",
  "AUD/USD": "67a6f93030f4217f2e8f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f",
  "CAD/USD": "9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a9a",
  // === Commodities ===
  "XAU/USD": "765d2ba906dbc32ca17cc11f5310a89e9ee1f6420508c63861f2f8ba4ee34bb2",
  "XAG/USD": "f2fb02c32b055c805e7238d628e5e9dadef274376114eb1f012337cabe93871e",
  "WTI/USD": "c9c8e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9e9",
  "BRENT/USD": "d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8",
  // === US Equities ===
  "AAPL/USD": "49f6b65cb1de6b10eaf75e7c03ca029c306d0357e91b5311b175084a5ad55688",
  "NVDA/USD": "b1073854ed24cbc755dc527418f52b7d271f6cc967bbf8d8129112b18860a593",
  "TSLA/USD": "16dad506d7db8da01c87581c87ca897a012a153557d4d578c3b9c9e1bc0632f1",
  "GOOGL/USD": "b7e3904c08ddd9c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0",
  "AMZN/USD": "c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6c6",
  "MSFT/USD": "d0ca23c1cc005e004ccf1db5bf76aeb6a49218f43dac3d4b275e92de12ea4b77",
  "META/USD": "a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4",
  "COIN/USD": "9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b",
  "SPY/USD": "19e09bb805456ada3979a7d1cbb4b6d63babc3a0f8e8a9b3c4d5e6f7a8b9c0d1",
  "QQQ/USD": "2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e"
};
var PYTH_ABI = [
  {
    inputs: [{ name: "id", type: "bytes32" }],
    name: "getPrice",
    outputs: [
      {
        components: [
          { name: "price", type: "int64" },
          { name: "conf", type: "uint64" },
          { name: "expo", type: "int32" },
          { name: "publishTime", type: "uint256" }
        ],
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "id", type: "bytes32" }],
    name: "getPriceNoOlderThan",
    outputs: [
      {
        components: [
          { name: "price", type: "int64" },
          { name: "conf", type: "uint64" },
          { name: "expo", type: "int32" },
          { name: "publishTime", type: "uint256" }
        ],
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "id", type: "bytes32" },
      { name: "age", type: "uint256" }
    ],
    name: "getPriceNoOlderThan",
    outputs: [
      {
        components: [
          { name: "price", type: "int64" },
          { name: "conf", type: "uint64" },
          { name: "expo", type: "int32" },
          { name: "publishTime", type: "uint256" }
        ],
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "id", type: "bytes32" }],
    name: "getPriceUnsafe",
    outputs: [
      {
        components: [
          { name: "price", type: "int64" },
          { name: "conf", type: "uint64" },
          { name: "expo", type: "int32" },
          { name: "publishTime", type: "uint256" }
        ],
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "id", type: "bytes32" }],
    name: "getEmaPrice",
    outputs: [
      {
        components: [
          { name: "price", type: "int64" },
          { name: "conf", type: "uint64" },
          { name: "expo", type: "int32" },
          { name: "publishTime", type: "uint256" }
        ],
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "updateData", type: "bytes[]" }],
    name: "updatePriceFeeds",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ name: "updateData", type: "bytes[]" }],
    name: "getUpdateFee",
    outputs: [{ name: "feeAmount", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "id", type: "bytes32" }],
    name: "priceFeedExists",
    outputs: [{ name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "updateData", type: "bytes[]" },
      { name: "priceIds", type: "bytes32[]" },
      { name: "minPublishTime", type: "uint64" },
      { name: "maxPublishTime", type: "uint64" }
    ],
    name: "parsePriceFeedUpdates",
    outputs: [
      {
        components: [
          { name: "id", type: "bytes32" },
          {
            components: [
              { name: "price", type: "int64" },
              { name: "conf", type: "uint64" },
              { name: "expo", type: "int32" },
              { name: "publishTime", type: "uint256" }
            ],
            name: "price",
            type: "tuple"
          },
          {
            components: [
              { name: "price", type: "int64" },
              { name: "conf", type: "uint64" },
              { name: "expo", type: "int32" },
              { name: "publishTime", type: "uint256" }
            ],
            name: "emaPrice",
            type: "tuple"
          }
        ],
        name: "",
        type: "tuple[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  }
];
var TOKEN_ADDRESS_TO_PRICE_FEED = {
  // Native and Wrapped tokens
  "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE": { pair: "MNT/USD", feedId: PYTH_PRICE_FEED_IDS["MNT/USD"] },
  // Native MNT
  "0x78c1b0C915c4FAA5FffA6CAbf0219DA63d7f4cb8": { pair: "MNT/USD", feedId: PYTH_PRICE_FEED_IDS["MNT/USD"] },
  // WMNT
  "0xdEAddEaDdeadDEadDEADDEAddEADDEAddead1111": { pair: "ETH/USD", feedId: PYTH_PRICE_FEED_IDS["ETH/USD"] },
  // WETH
  // Stablecoins
  "0x09Bc4E0D10C81b3a3766c49F0f98a8aaa7adA8D2": { pair: "USDC/USD", feedId: PYTH_PRICE_FEED_IDS["USDC/USD"] },
  // USDC
  "0x201EBa5CC46D216Ce6DC03F6a759e8E766e956aE": { pair: "USDT/USD", feedId: PYTH_PRICE_FEED_IDS["USDT/USD"] },
  // USDT
  // LST Tokens
  "0xcDA86A272531e8640cD7F1a92c01839911B90bb0": { pair: "mETH/USD", feedId: PYTH_PRICE_FEED_IDS["mETH/USD"] },
  // mETH
  // Additional Mantle tokens (commonly traded)
  "0xCAbAE6f6Ea1ecaB08Ad02fE02ce9A44F09aebfA2": { pair: "WBTC/USD", feedId: PYTH_PRICE_FEED_IDS["WBTC/USD"] },
  // WBTC
  "0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000": { pair: "ETH/USD", feedId: PYTH_PRICE_FEED_IDS["ETH/USD"] },
  // ETH (canonical)
  // USDe and other stablecoins
  "0x5d3a1Ff2b6BAb83b63cd9AD0787074081a52ef34": { pair: "USDC/USD", feedId: PYTH_PRICE_FEED_IDS["USDC/USD"] },
  // USDe (pegged to USD)
  // Pendle
  "0xf83bcc06D6A4A5682adeCA11CF9500f67bFe61AE": { pair: "PENDLE/USD", feedId: PYTH_PRICE_FEED_IDS["PENDLE/USD"] },
  // PENDLE
  // FBTC
  "0xc96de26018a54d51c097160568752c4e3bd6c364": { pair: "BTC/USD", feedId: PYTH_PRICE_FEED_IDS["BTC/USD"] },
  // FBTC
  // Aurelius tokens (staked versions)
  "0xe6829d9a7eE3040e1276Fa75293Bde931859e8fA": { pair: "MNT/USD", feedId: PYTH_PRICE_FEED_IDS["MNT/USD"] }
  // cmETH
};
function isTokenAddress(input) {
  return /^0x[a-fA-F0-9]{40}$/i.test(input);
}
function resolvePriceFeedInput(input) {
  const normalizedInput = input.toLowerCase();
  if (isTokenAddress(input)) {
    for (const [addr, info] of Object.entries(TOKEN_ADDRESS_TO_PRICE_FEED)) {
      if (addr.toLowerCase() === normalizedInput) {
        return { pair: info.pair, feedId: info.feedId };
      }
    }
    return null;
  }
  if (input in PYTH_PRICE_FEED_IDS) {
    return {
      pair: input,
      feedId: PYTH_PRICE_FEED_IDS[input]
    };
  }
  const normalizedId = input.replace("0x", "");
  const foundPair = Object.entries(PYTH_PRICE_FEED_IDS).find(
    ([, id]) => id === normalizedId
  );
  if (foundPair) {
    return { pair: foundPair[0], feedId: foundPair[1] };
  }
  return null;
}

// src/tools/pyth/getPrice.ts
async function pythGetPrice(agent, input) {
  const pythAddress = PYTH_CONTRACT[agent.chain];
  const resolved = resolvePriceFeedInput(input);
  let priceFeedId;
  let pair;
  if (resolved) {
    priceFeedId = resolved.feedId;
    pair = resolved.pair;
  } else {
    priceFeedId = input;
    pair = input;
  }
  const feedId = priceFeedId.startsWith("0x") ? priceFeedId : `0x${priceFeedId}`;
  if (agent.demo) {
    return createMockPythResponse(pair, feedId);
  }
  try {
    const priceData = await agent.client.readContract({
      address: pythAddress,
      abi: PYTH_ABI,
      functionName: "getPriceUnsafe",
      args: [feedId]
    });
    const price = Number(priceData.price);
    const confidence = Number(priceData.conf);
    const exponent = priceData.expo;
    const publishTime = Number(priceData.publishTime);
    const formattedPrice = formatPythPrice(price, exponent);
    return {
      priceFeedId: feedId,
      pair,
      price: priceData.price.toString(),
      confidence: priceData.conf.toString(),
      exponent,
      publishTime,
      formattedPrice
    };
  } catch (error) {
    throw new Error(
      `Failed to fetch price from Pyth: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function pythGetEmaPrice(agent, input) {
  const pythAddress = PYTH_CONTRACT[agent.chain];
  const resolved = resolvePriceFeedInput(input);
  let priceFeedId;
  let pair;
  if (resolved) {
    priceFeedId = resolved.feedId;
    pair = resolved.pair;
  } else {
    priceFeedId = input;
    pair = input;
  }
  const feedId = priceFeedId.startsWith("0x") ? priceFeedId : `0x${priceFeedId}`;
  if (agent.demo) {
    return createMockPythResponse(pair, feedId);
  }
  try {
    const priceData = await agent.client.readContract({
      address: pythAddress,
      abi: PYTH_ABI,
      functionName: "getEmaPrice",
      args: [feedId]
    });
    const formattedPrice = formatPythPrice(
      Number(priceData.price),
      priceData.expo
    );
    return {
      priceFeedId: feedId,
      pair,
      price: priceData.price.toString(),
      confidence: priceData.conf.toString(),
      exponent: priceData.expo,
      publishTime: Number(priceData.publishTime),
      formattedPrice
    };
  } catch (error) {
    throw new Error(
      `Failed to fetch EMA price from Pyth: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
function formatPythPrice(price, exponent) {
  const adjustedPrice = price * Math.pow(10, exponent);
  if (adjustedPrice >= 1) {
    return adjustedPrice.toFixed(2);
  } else {
    return adjustedPrice.toFixed(8);
  }
}
async function pythGetTokenPrice(agent, tokenAddress) {
  if (!isTokenAddress(tokenAddress)) {
    throw new Error(
      `Invalid token address format: ${tokenAddress}. Must be a valid Ethereum address (0x...)`
    );
  }
  const normalizedAddress = tokenAddress.toLowerCase();
  let tokenInfo = null;
  let originalAddress = tokenAddress;
  for (const [addr, info] of Object.entries(TOKEN_ADDRESS_TO_PRICE_FEED)) {
    if (addr.toLowerCase() === normalizedAddress) {
      tokenInfo = info;
      originalAddress = addr;
      break;
    }
  }
  if (!tokenInfo) {
    throw new Error(
      `Token address not supported: ${tokenAddress}. Use pythGetSupportedTokenAddresses() to see available tokens.`
    );
  }
  const tokenSymbol = tokenInfo.pair.split("/")[0] || "UNKNOWN";
  const feedId = tokenInfo.feedId.startsWith("0x") ? tokenInfo.feedId : `0x${tokenInfo.feedId}`;
  if (agent.demo) {
    return createMockTokenPriceResponse(
      originalAddress,
      tokenSymbol,
      tokenInfo.pair,
      feedId
    );
  }
  const pythAddress = PYTH_CONTRACT[agent.chain];
  try {
    const priceData = await agent.client.readContract({
      address: pythAddress,
      abi: PYTH_ABI,
      functionName: "getPriceUnsafe",
      args: [feedId]
    });
    const formattedPrice = formatPythPrice(
      Number(priceData.price),
      priceData.expo
    );
    const publishTime = Number(priceData.publishTime);
    return {
      tokenAddress: originalAddress,
      tokenSymbol,
      pair: tokenInfo.pair,
      priceFeedId: feedId,
      priceUsd: formattedPrice,
      confidence: priceData.conf.toString(),
      exponent: priceData.expo,
      publishTime,
      lastUpdated: new Date(publishTime * 1e3).toISOString()
    };
  } catch (error) {
    throw new Error(
      `Failed to fetch price for token ${tokenAddress}: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
function createMockPythResponse(pair, feedId) {
  const mockPrices = {
    // Major Crypto
    "BTC/USD": 97500,
    "ETH/USD": 3450,
    "SOL/USD": 185,
    "BNB/USD": 680,
    "XRP/USD": 2.35,
    "ADA/USD": 0.95,
    "DOGE/USD": 0.32,
    "DOT/USD": 7.2,
    "AVAX/USD": 38,
    "MATIC/USD": 0.48,
    "LINK/USD": 22,
    "ATOM/USD": 9.5,
    "LTC/USD": 105,
    "UNI/USD": 13.5,
    "NEAR/USD": 5.2,
    "TRX/USD": 0.25,
    // L2
    "ARB/USD": 0.85,
    "OP/USD": 1.95,
    "MNT/USD": 0.85,
    "STRK/USD": 0.45,
    // DeFi
    "AAVE/USD": 285,
    "CRV/USD": 0.52,
    "MKR/USD": 1850,
    "SNX/USD": 2.8,
    "LDO/USD": 1.85,
    "GMX/USD": 28,
    "PENDLE/USD": 4.2,
    // Stablecoins
    "USDC/USD": 1,
    "USDT/USD": 1,
    "DAI/USD": 1,
    // LST
    "mETH/USD": 3500,
    "stETH/USD": 3450,
    "wstETH/USD": 4100,
    // Meme
    "SHIB/USD": 22e-6,
    "PEPE/USD": 18e-6,
    "BONK/USD": 28e-6,
    "WIF/USD": 1.85,
    // Commodities
    "XAU/USD": 2650,
    "XAG/USD": 31,
    // Forex
    "EUR/USD": 1.08,
    "GBP/USD": 1.27,
    "JPY/USD": 67e-4,
    // Equities
    "AAPL/USD": 248,
    "NVDA/USD": 138,
    "TSLA/USD": 385,
    "MSFT/USD": 425
  };
  const price = mockPrices[pair] || 100;
  const decimals = price < 0.01 ? 8 : price < 1 ? 4 : 2;
  return {
    priceFeedId: feedId,
    pair,
    price: Math.floor(price * 1e8).toString(),
    confidence: "50000",
    exponent: -8,
    publishTime: Math.floor(Date.now() / 1e3),
    formattedPrice: price.toFixed(decimals)
  };
}
function createMockTokenPriceResponse(tokenAddress, tokenSymbol, pair, feedId) {
  const mockPrices = {
    USDC: 1,
    USDT: 1,
    DAI: 1,
    ETH: 3450,
    WETH: 3450,
    BTC: 97500,
    WBTC: 97500,
    MNT: 0.85,
    WMNT: 0.85,
    mETH: 3500,
    PENDLE: 4.2
  };
  const price = mockPrices[tokenSymbol] || 100;
  const publishTime = Math.floor(Date.now() / 1e3);
  return {
    tokenAddress,
    tokenSymbol,
    pair,
    priceFeedId: feedId,
    priceUsd: price.toFixed(price < 1 ? 4 : 2),
    confidence: "50000",
    exponent: -8,
    publishTime,
    lastUpdated: new Date(publishTime * 1e3).toISOString()
  };
}

// src/tools/pyth/getMultiplePrices.ts
async function pythGetMultiplePrices(agent, inputs) {
  const pythAddress = PYTH_CONTRACT[agent.chain];
  const results = [];
  for (const input of inputs) {
    const resolved = resolvePriceFeedInput(input);
    let priceFeedId;
    let pair;
    if (resolved) {
      priceFeedId = resolved.feedId;
      pair = resolved.pair;
    } else {
      priceFeedId = input;
      pair = input;
    }
    const feedId = priceFeedId.startsWith("0x") ? priceFeedId : `0x${priceFeedId}`;
    if (agent.demo) {
      results.push(createMockPythResponse2(pair, feedId));
      continue;
    }
    try {
      const priceData = await agent.client.readContract({
        address: pythAddress,
        abi: PYTH_ABI,
        functionName: "getPriceUnsafe",
        args: [feedId]
      });
      const formattedPrice = formatPythPrice2(
        Number(priceData.price),
        priceData.expo
      );
      results.push({
        priceFeedId: feedId,
        pair,
        price: priceData.price.toString(),
        confidence: priceData.conf.toString(),
        exponent: priceData.expo,
        publishTime: Number(priceData.publishTime),
        formattedPrice
      });
    } catch (error) {
      results.push({
        priceFeedId: feedId,
        pair,
        price: "0",
        confidence: "0",
        exponent: 0,
        publishTime: 0,
        formattedPrice: "Error fetching price"
      });
    }
  }
  return results;
}
function pythGetSupportedPriceFeeds() {
  return { ...PYTH_PRICE_FEED_IDS };
}
function pythGetSupportedTokenAddresses() {
  const result = {};
  for (const [address, info] of Object.entries(TOKEN_ADDRESS_TO_PRICE_FEED)) {
    result[address] = info.pair;
  }
  return result;
}
async function pythPriceFeedExists(agent, input) {
  const pythAddress = PYTH_CONTRACT[agent.chain];
  const resolved = resolvePriceFeedInput(input);
  let priceFeedId;
  if (resolved) {
    priceFeedId = resolved.feedId;
  } else {
    priceFeedId = input;
  }
  const feedId = priceFeedId.startsWith("0x") ? priceFeedId : `0x${priceFeedId}`;
  if (agent.demo) {
    return resolved !== null;
  }
  try {
    const exists = await agent.client.readContract({
      address: pythAddress,
      abi: PYTH_ABI,
      functionName: "priceFeedExists",
      args: [feedId]
    });
    return exists;
  } catch {
    return false;
  }
}
function formatPythPrice2(price, exponent) {
  const adjustedPrice = price * Math.pow(10, exponent);
  if (adjustedPrice >= 1) {
    return adjustedPrice.toFixed(2);
  }
  return adjustedPrice.toFixed(8);
}
function createMockPythResponse2(pair, feedId) {
  const mockPrices = {
    // Major Crypto
    "BTC/USD": 97500,
    "ETH/USD": 3450,
    "SOL/USD": 185,
    "BNB/USD": 680,
    "XRP/USD": 2.35,
    "ADA/USD": 0.95,
    "DOGE/USD": 0.32,
    "DOT/USD": 7.2,
    "AVAX/USD": 38,
    "MATIC/USD": 0.48,
    "LINK/USD": 22,
    "ATOM/USD": 9.5,
    "LTC/USD": 105,
    "UNI/USD": 13.5,
    "NEAR/USD": 5.2,
    "TRX/USD": 0.25,
    // L2
    "ARB/USD": 0.85,
    "OP/USD": 1.95,
    "MNT/USD": 0.85,
    "STRK/USD": 0.45,
    // DeFi
    "AAVE/USD": 285,
    "CRV/USD": 0.52,
    "MKR/USD": 1850,
    "SNX/USD": 2.8,
    "LDO/USD": 1.85,
    "GMX/USD": 28,
    "PENDLE/USD": 4.2,
    // Stablecoins
    "USDC/USD": 1,
    "USDT/USD": 1,
    "DAI/USD": 1,
    // LST
    "mETH/USD": 3500,
    "stETH/USD": 3450,
    "wstETH/USD": 4100,
    // Meme
    "SHIB/USD": 22e-6,
    "PEPE/USD": 18e-6,
    "BONK/USD": 28e-6,
    "WIF/USD": 1.85,
    // Commodities
    "XAU/USD": 2650,
    "XAG/USD": 31,
    // Forex
    "EUR/USD": 1.08,
    "GBP/USD": 1.27,
    "JPY/USD": 67e-4,
    // Equities
    "AAPL/USD": 248,
    "NVDA/USD": 138,
    "TSLA/USD": 385,
    "MSFT/USD": 425
  };
  const price = mockPrices[pair] || 100;
  const decimals = price < 0.01 ? 8 : price < 1 ? 4 : 2;
  return {
    priceFeedId: feedId,
    pair,
    price: Math.floor(price * 1e8).toString(),
    confidence: "50000",
    exponent: -8,
    publishTime: Math.floor(Date.now() / 1e3),
    formattedPrice: price.toFixed(decimals)
  };
}

// src/constants/token-launchpad/index.ts
var token_launchpad_exports = {};
__export(token_launchpad_exports, {
  ERC20_ABI: () => ERC20_ABI
});
var ERC20_ABI = [
  {
    inputs: [],
    name: "name",
    outputs: [{ name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [{ name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "to", type: "address" },
      { name: "amount", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// src/tools/token-launchpad/deployToken.ts
var ERC20_BYTECODE = "0x608060405234801561001057600080fd5b5060405161089a38038061089a833981016040819052610032916101db565b8251839083906100499060039060208501906100b4565b50805161005d9060049060208401906100b4565b50505061007a33826100756012600a6102eb565b610081565b5050610359565b6001600160a01b0382166100ab5760405163ec442f0560e01b815260006004820152602401604051809103906000fd5b6100b760008383610140565b5050565b8280546100c09061030c565b90600052602060002090601f0160209004810192826100e2576000855561012e565b82601f106100f357805160ff191683800117855561012e565b8280016001018555821561012e579182015b8281111561012e578251825591602001919060010190610105565b5061013a92915061013e565b5090565b5b8082111561013a576000815560010161013f565b6001600160a01b038316610174578060026000828254610160919061034b565b9091555061019f9050565b6001600160a01b0383166000908152602081905260408120805483929061019c908490610346565b90915550505b6001600160a01b0382166101c1576002805482900390556101e6565b6001600160a01b03821660009081526020819052604081208054839290610169908490610346565b816001600160a01b0316836001600160a01b03166000805160206108228339815191528360405161021991815260200190565b60405180910390a3505050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561025757818101518382015260200161023f565b83811115610268576000848401525b50505050565b600082601f83011261027e578081fd5b81516001600160401b038082111561029857610298610226565b604051601f8301601f19908116603f011681019082821181831017156102c0576102c0610226565b816040528381528660208588010111156102d8578485fd5b6102e9846020830160208901610240565b9695505050505050565b60008060006060848603121561030757600080fd5b83516001600160401b038082111561031d578586fd5b6103298783880161026e565b9450602086015191508082111561033e578384fd5b5061034b8682870161026e565b925050604084015190509250925092565b634e487b7160e01b600052601160045260246000fd5b600181815b808511156103ad57816000190482111561039357610393610372565b808516156103a057918102915b93841c939080029061037c565b509250929050565b6000826103c457506001610460565b816103d157506000610460565b81600181146103e757600281146103f15761040d565b6001915050610460565b60ff84111561040257610402610372565b50506001821b610460565b5060208310610133831016604e8410600b8410161715610430575081810a610460565b61043a8383610377565b806000190482111561044e5761044e610372565b029392505050565b600061046283836103b5565b9392505050565b61046b610482565b600082821015610479576104796103a2565b50039056fe";
var RWA_BYTECODE = "0x608060405234801561001057600080fd5b5060405161089a38038061089a833981016040819052610032916101db565b8251839083906100499060039060208501906100b4565b50805161005d9060049060208401906100b4565b50505061007a33826100756012600a6102eb565b610081565b5050610359565b6001600160a01b0382166100ab5760405163ec442f0560e01b815260006004820152602401604051809103906000fd5b6100b760008383610140565b5050565b8280546100c09061030c565b90600052602060002090601f0160209004810192826100e2576000855561012e565b82601f106100f357805160ff191683800117855561012e565b8280016001018555821561012e579182015b8281111561012e578251825591602001919060010190610105565b5061013a92915061013e565b5090565b5b8082111561013a576000815560010161013f565b6001600160a01b038316610174578060026000828254610160919061034b565b9091555061019f9050565b6001600160a01b0383166000908152602081905260408120805483929061019c908490610346565b90915550505b6001600160a01b0382166101c1576002805482900390556101e6565b6001600160a01b03821660009081526020819052604081208054839290610169908490610346565b816001600160a01b0316836001600160a01b03166000805160206108228339815191528360405161021991815260200190565b60405180910390a3505050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561025757818101518382015260200161023f565b83811115610268576000848401525b50505050565b600082601f83011261027e578081fd5b81516001600160401b038082111561029857610298610226565b604051601f8301601f19908116603f011681019082821181831017156102c0576102c0610226565b816040528381528660208588010111156102d8578485fd5b6102e9846020830160208901610240565b9695505050505050565b60008060006060848603121561030757600080fd5b83516001600160401b038082111561031d578586fd5b6103298783880161026e565b9450602086015191508082111561033e578384fd5b5061034b8682870161026e565b925050604084015190509250925092565b634e487b7160e01b600052601160045260246000fd5b600181815b808511156103ad57816000190482111561039357610393610372565b808516156103a057918102915b93841c939080029061037c565b509250929050565b6000826103c457506001610460565b816103d157506000610460565b81600181146103e757600281146103f15761040d565b6001915050610460565b60ff84111561040257610402610372565b50506001821b610460565b5060208310610133831016604e8410600b8410161715610430575081810a610460565b61043a8383610377565b806000190482111561044e5761044e610372565b029392505050565b600061046283836103b5565b9392505050565b61046b610482565b600082821015610479576104796103a2565b50039056fe";
async function deployToken(agent, name, symbol, supply, tokenType = "standard", assetType, assetId) {
  const decimals = 18;
  const supplyInWei = viem.parseUnits(supply, decimals).toString();
  if (agent.demo) {
    return {
      tokenAddress: `0xDEMO${tokenType === "rwa" ? "RWA" : "TKN"}00000000000000000001`,
      txHash: DEMO_TX_HASH,
      name,
      symbol,
      decimals,
      totalSupply: supplyInWei,
      mintedTo: agent.account.address,
      tokenType,
      assetType,
      assetId
    };
  }
  if (!name?.trim()) throw new Error("Token name required");
  if (!symbol?.trim()) throw new Error("Token symbol required");
  if (!supply || Number(supply) <= 0) throw new Error("Supply must be > 0");
  const args = viem.encodeAbiParameters(
    viem.parseAbiParameters("string, string, uint256"),
    [name, symbol, BigInt(supplyInWei)]
  );
  const bytecode = tokenType === "rwa" ? RWA_BYTECODE : ERC20_BYTECODE;
  const deployData = bytecode + args.slice(2);
  const txHash = await agent.client.sendTransaction({ data: deployData });
  const receipt = await agent.client.waitForTransactionReceipt({ hash: txHash });
  if (!receipt.contractAddress) {
    throw new Error("Deployment failed - no contract address");
  }
  return {
    tokenAddress: receipt.contractAddress,
    txHash,
    name,
    symbol,
    decimals,
    totalSupply: supplyInWei,
    mintedTo: agent.account.address,
    tokenType,
    assetType,
    assetId
  };
}
async function deployStandardToken(agent, name, symbol, supply) {
  return deployToken(agent, name, symbol, supply, "standard");
}
async function deployRWAToken(agent, name, symbol, supply, assetType, assetId) {
  return deployToken(agent, name, symbol, supply, "rwa", assetType, assetId);
}
async function getTokenInfo(agent, tokenAddress, holder) {
  if (agent.demo) {
    return {
      address: tokenAddress,
      name: "Demo Token",
      symbol: "DEMO",
      decimals: 18,
      totalSupply: "1000000000000000000000000",
      balance: holder ? "1000000000000000000000" : void 0
    };
  }
  const [name, symbol, decimals, totalSupply] = await Promise.all([
    agent.client.readContract({ address: tokenAddress, abi: viem.erc20Abi, functionName: "name" }),
    agent.client.readContract({ address: tokenAddress, abi: viem.erc20Abi, functionName: "symbol" }),
    agent.client.readContract({ address: tokenAddress, abi: viem.erc20Abi, functionName: "decimals" }),
    agent.client.readContract({ address: tokenAddress, abi: viem.erc20Abi, functionName: "totalSupply" })
  ]);
  const result = {
    address: tokenAddress,
    name,
    symbol,
    decimals,
    totalSupply: totalSupply.toString()
  };
  if (holder) {
    const balance = await agent.client.readContract({
      address: tokenAddress,
      abi: viem.erc20Abi,
      functionName: "balanceOf",
      args: [holder]
    });
    result.balance = balance.toString();
  }
  return result;
}
async function getTokenBalance(agent, tokenAddress, holder) {
  if (agent.demo) return "1000000000000000000000";
  const balance = await agent.client.readContract({
    address: tokenAddress,
    abi: viem.erc20Abi,
    functionName: "balanceOf",
    args: [holder || agent.account.address]
  });
  return balance.toString();
}
async function transferToken(agent, tokenAddress, to, amount) {
  if (agent.demo) return DEMO_TX_HASH;
  const data = viem.encodeFunctionData({
    abi: viem.erc20Abi,
    functionName: "transfer",
    args: [to, BigInt(amount)]
  });
  const txHash = await agent.client.sendTransaction({ to: tokenAddress, data });
  await agent.client.waitForTransactionReceipt({ hash: txHash });
  return txHash;
}

// src/constants/nft-launchpad/index.ts
var nft_launchpad_exports = {};
__export(nft_launchpad_exports, {
  ERC721_ABI: () => ERC721_ABI
});
var ERC721_ABI = [
  // Constructor-related
  {
    inputs: [
      { name: "name", type: "string" },
      { name: "symbol", type: "string" },
      { name: "baseURI", type: "string" },
      { name: "maxSupply", type: "uint256" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  // View functions
  {
    inputs: [],
    name: "name",
    outputs: [{ name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "tokenId", type: "uint256" }],
    name: "tokenURI",
    outputs: [{ name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "tokenId", type: "uint256" }],
    name: "ownerOf",
    outputs: [{ name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "owner", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "tokenId", type: "uint256" }],
    name: "getApproved",
    outputs: [{ name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "owner", type: "address" },
      { name: "operator", type: "address" }
    ],
    name: "isApprovedForAll",
    outputs: [{ name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  // State changing functions
  {
    inputs: [{ name: "to", type: "address" }],
    name: "mint",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "to", type: "address" },
      { name: "quantity", type: "uint256" }
    ],
    name: "batchMint",
    outputs: [{ name: "startTokenId", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "to", type: "address" },
      { name: "tokenId", type: "uint256" }
    ],
    name: "approve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "operator", type: "address" },
      { name: "approved", type: "bool" }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "from", type: "address" },
      { name: "to", type: "address" },
      { name: "tokenId", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "from", type: "address" },
      { name: "to", type: "address" },
      { name: "tokenId", type: "uint256" }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "from", type: "address" },
      { name: "to", type: "address" },
      { name: "tokenId", type: "uint256" },
      { name: "data", type: "bytes" }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  // Events
  {
    anonymous: false,
    inputs: [
      { indexed: true, name: "from", type: "address" },
      { indexed: true, name: "to", type: "address" },
      { indexed: true, name: "tokenId", type: "uint256" }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, name: "owner", type: "address" },
      { indexed: true, name: "approved", type: "address" },
      { indexed: true, name: "tokenId", type: "uint256" }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, name: "owner", type: "address" },
      { indexed: true, name: "operator", type: "address" },
      { indexed: false, name: "approved", type: "bool" }
    ],
    name: "ApprovalForAll",
    type: "event"
  }
];

// src/tools/nft-launchpad/deployCollection.ts
var ERC721_CREATION_CODE = `0x608060405234801561001057600080fd5b506040516112a03803806112a0833981016040819052610032916101e5565b83838383600061004283826102f4565b50600161004f82826102f4565b5050600680546001600160a01b0319163317905550600782905560088190555050505050506103b3565b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009f57600080fd5b81516001600160401b03808211156100b9576100b9610079565b604051601f8301601f19908116603f011681019082821181831017156100e1576100e1610079565b816040528381526020925086838588010111156100fd57600080fd5b600091505b8382101561011f5785820183015181830184015290820190610102565b6000928101909201929092529392505050565b60008060008060808587031215610148578384fd5b84516001600160401b038082111561015e578586fd5b61016a8883890161008f565b9550602087015191508082111561017f578485fd5b5061018c8782880161008f565b9350506040850151915060608501519050929550929550929292909250565b600181811c908216806101bf57607f821691505b6020821081036101df57634e487b7160e01b600052602260045260246000fd5b50919050565b600080600080608085870312156101fa578384fd5b84516001600160401b0380821115610210578586fd5b61021c8883890161008f565b95506020870151915080821115610231578485fd5b5061023e8782880161008f565b935050604085015191506060850151905092959194509250565b601f82111561029f57600081815260208120601f850160051c8101602086101561027f5750805b601f850160051c820191505b8181101561029e5782815560010161028b565b505050505050565b81516001600160401b038111156102bf576102bf610079565b6102d3816102cd84546101ab565b84610258565b602080601f83116001811461030857600084156102f05750858301515b600019600386901b1c1916600185901b17855561029e565b600085815260208120601f198616915b8281101561033757888601518255948401946001909101908401610318565b50858210156103555787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b600082601f83011261037657600080fd5b81356001600160401b0381111561038f5761038f610079565b6040516020601f19601f85011681018181106001600160401b03821117156103b9576103b9610079565b6040528281528484830111156103ce57600080fd5b8282602083013760009201829052509392505050565b600080600080608085870312156103f9578384fd5b84356001600160401b038082111561040f578586fd5b61041b88838901610365565b95506020870135915080821115610430578485fd5b5061043d87828801610365565b935050604085013591506060850135905092959194509250565b610ede806103c26000396000f3fe608060405234801561001057600080fd5b50600436106100f55760003560e01c80636352211e11610097578063a22cb46511610066578063a22cb465146101f3578063b88d4fde14610206578063c87b56dd14610219578063e985e9c51461022c57600080fd5b80636352211e146101a75780636a627842146101ba57806370a08231146101cd57806395d89b41146101eb57600080fd5b8063095ea7b3116100d3578063095ea7b31461016257806318160ddd1461017757806323b872dd1461018157806342842e0e1461019457600080fd5b806301ffc9a7146100fa57806306fdde0314610122578063081812fc14610137575b600080fd5b61010d610108366004610b4a565b610268565b60405190151581526020015b60405180910390f35b61012a6102ba565b6040516101199190610bb7565b61014a610145366004610bca565b61034c565b6040516001600160a01b039091168152602001610119565b610175610170366004610bff565b610373565b005b6005545b604051908152602001610119565b61017561018f366004610c29565b61048d565b6101756101a2366004610c29565b6104be565b61014a6101b5366004610bca565b6104d9565b61017b6101c8366004610c65565b610539565b61017b6101db366004610c65565b6001600160a01b031660009081526003602052604090205490565b61012a6105d6565b610175610201366004610c80565b6105e5565b610175610214366004610cd2565b6105f4565b61012a610227366004610bca565b61062c565b61010d61023a366004610dae565b6001600160a01b03918216600090815260046020908152604080832093909416825291909152205460ff1690565b60006001600160e01b031982166380ac58cd60e01b148061029957506001600160e01b03198216635b5e139f60e01b145b806102b457506301ffc9a760e01b6001600160e01b03198316145b92915050565b6060600080546102c990610de1565b80601f01602080910402602001604051908101604052809291908181526020018280546102f590610de1565b80156103425780601f1061031757610100808354040283529160200191610342565b820191906000526020600020905b81548152906001019060200180831161032557829003601f168201915b5050505050905090565b600061035782610697565b506000908152600260205260409020546001600160a01b031690565b600061037e826104d9565b9050806001600160a01b0316836001600160a01b0316036103f05760405162461bcd60e51b815260206004820152602160248201527f4552433732313a20617070726f76616c20746f2063757272656e74206f776e656044820152603960f91b60648201526084015b60405180910390fd5b336001600160a01b038216148061040c575061040c813361023a565b61047e5760405162461bcd60e51b815260206004820152603d60248201527f4552433732313a20617070726f76652063616c6c6572206973206e6f7420746f60448201527f6b656e206f776e6572206f7220617070726f76656420666f7220616c6c00000060648201526084016103e7565b61048883836106f6565b505050565b6104973382610764565b6104b35760405162461bcd60e51b81526004016103e790610e1b565b6104888383836107c3565b61048883838360405180602001604052806000815250610930565b6000818152600260205260408120546001600160a01b0316806102b45760405162461bcd60e51b8152602060048201526018602482015277115490cdcc8c4e881a5b9d985b1a59081d1bdad95b88125160421b60448201526064016103e7565b6006546000906001600160a01b031633146105965760405162461bcd60e51b815260206004820152601960248201527f4f6e6c79206f776e65722063616e206d696e7420746f6b656e730000000000006044820152606401610e7565b600580549060006105a683610e68565b91905055905060075460001480156105bf575060075481115b156105c957600080fd5b6105d38382610944565b50919050565b6060600180546102c990610de1565b6105f033838361095e565b5050565b6105fe3383610764565b61061a5760405162461bcd60e51b81526004016103e790610e1b565b61062684848484610a2c565b50505050565b606061063782610697565b600061064e60408051602081019091526000815290565b9050600081511161066e5760405180602001604052806000815250610690565b8061067884610a5f565b604051602001610689929190610e81565b6040519091905056fe60005b838110156106ae578181015183820152602001610696565b50506000910152565b60006102b4826001600160a01b03163b151590565b806001600160a01b0316826001600160a01b0316036107225760405162461bcd60e51b815260206004820152601960248201527f4552433732313a20617070726f76616c20746f2073656c660000000000000000604482015260640160405180910390fd5b6001600160a01b03838116600081815260046020908152604080832094871680845294825291829020805460ff191686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b6001600160a01b0382166107b25760405162461bcd60e51b815260206004820152601160248201527045524337323: 696e76616c6964206164647260781b604482015260640160405180910390fd5b6000818152600260205260408120546001600160a01b0316906107d490610aff565b6001600160a01b0384166000908152600360205260408120805460019290610807908490610eb0565b909155505060008281526002602052604080822080546001600160a01b0319166001600160a01b0387811691821790925591518593918516917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a4505050565b6000818152600260205260408120546001600160a01b031661092c5760405162461bcd60e51b815260206004820152602c60248201527f4552433732313a206f70657261746f7220717565727920666f72206e6f6e657860448201526b34b9ba32b73a103a37b5b2b760a11b606482015260840160405180910390fd5b6000610937836104d9565b9050806001600160a01b0316846001600160a01b031614806109725750836001600160a01b03166109678461034c565b6001600160a01b0316145b8061098257506109828185610b23565b949350505050565b61098d8484846107c3565b61099984848484610b4c565b6106265760405162461bcd60e51b81526004016103e790610ec3565b6105f08282604051806020016040528060008152506109d3836109b5565b6109bf8383610a2c565b6109cc6000848484610b4c565b5050505050565b816001600160a01b0316836001600160a01b0316036109fe5760405162461bcd60e51b81526004016103e790610f0c565b6001600160a01b0382811660008181526004602090815260408083209487168084529482529182902080548615157fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00909116179055905190825290917f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c3191015b60405180910390a3505050565b610a376107c3565b610a4384848484610c25565b5050505050565b60606000610a5783610c58565b600101905060008167ffffffffffffffff811115610a7757610a77610cbc565b6040519080825280601f01601f191660200182016040528015610aa1576020820181803683370190505b5090508181016020015b600019016f181899199a1a9b1b9c1cb0b131b232b360811b600a86061a8153600a8504945084610aab57509392505050565b600060001982015b6000838152600260205260409020546001600160a01b0316610b085750919050565b8015610b145792915050565b82610b1e81610f4f565b935050610b07565b6001600160a01b03918216600090815260046020908152604080832093909416825291909152205460ff1690565b60006001600160a01b0384163b15610c1a57604051630a85bd0160e11b81526001600160a01b0385169063150b7a0290610b90903390899088908890600401610f66565b6020604051808303816000875af1925050508015610bcb575060408051601f3d908101601f19168201909252610bc891810190610f99565b60015b610c00573d808015610bf9576040519150601f19603f3d011682016040523d82523d6000602084013e610bfe565b606091505b505080515f03610c185760405162461bcd60e51b81526004016103e790610ec3565b505b6001600160e01b031916630a85bd0160e11b149050610982565b506001949350505050565b610c318484846107c3565b610c3d84848484610b4c565b6106265760405162461bcd60e51b81526004016103e790610ec3565b60008072184f03e93ff9f4daa797ed6e38ed64bf6a1f0160401b8310610c975772184f03e93ff9f4daa797ed6e38ed64bf6a1f0160401b830492506040015b6d04ee2d6d415b85acef81000000008310610cc3576d04ee2d6d415b85acef8100000000830492506020015b662386f26fc100008310610ce157662386f26fc10000830492506010015b6305f5e1008310610cf9576305f5e100830492506008015b6127108310610d0d57612710830492506004015b60648310610d1f576064830492506002015b600a83106102b45760010192915050565b6001600160e01b031981168114610d4657600080fd5b50565b600060208284031215610d5a578081fd5b8135610d6581610d30565b9392505050565b60005b83811015610d87578181015183820152602001610d6f565b50506000910152565b60008151808452610da8816020860160208601610d6c565b601f01601f19169290920160200192915050565b602081526000610d656020830184610d90565b600060208284031215610de0578081fd5b5035919050565b80356001600160a01b0381168114610dfe57600080fd5b919050565b60008060408385031215610e15578081fd5b610e1e83610de7565b946020939093013593505050565b600080600060608486031215610e40578081fd5b610e4984610de7565b9250610e5760208501610de7565b9150604084013590509250925092565b600060208284031215610e78578081fd5b610d6582610de7565b60008060408385031215610e93578182fd5b610e9c83610de7565b915060208301358015158114610eb0578182fd5b809150509250929050565b634e487b7160e01b600052604160045260246000fd5b600082601f830112610ee1578081fd5b813567ffffffffffffffff80821115610efc57610efc610ebb565b604051601f8301601f19908116603f01168101908282118183101715610f2457610f24610ebb565b81604052838152866020858801011115610f3c578485fd5b83602087016020830137600060208583010152809450505050509291505056fea264697066735822122000000000000000000000000000000000000000000000000000000000000000064736f6c63430008150033`;
async function deployNFTCollection(agent, config) {
  const { name, symbol, baseURI, maxSupply = 0 } = config;
  if (agent.demo) {
    return {
      collectionAddress: "0xDEMO000000000000000000000000000000000002",
      txHash: DEMO_TX_HASH,
      name,
      symbol,
      baseURI,
      maxSupply,
      deployer: agent.account.address
    };
  }
  if (!name || name.length === 0) {
    throw new Error("Collection name is required");
  }
  if (!symbol || symbol.length === 0) {
    throw new Error("Collection symbol is required");
  }
  if (!baseURI) {
    throw new Error("Base URI is required for token metadata");
  }
  const constructorArgs = viem.encodeAbiParameters(
    viem.parseAbiParameters(
      "string name, string symbol, string baseURI, uint256 maxSupply"
    ),
    [name, symbol, baseURI, BigInt(maxSupply)]
  );
  const deploymentBytecode = ERC721_CREATION_CODE + constructorArgs.slice(2);
  const txHash = await agent.client.sendTransaction({
    data: deploymentBytecode
  });
  const receipt = await agent.client.waitForTransactionReceipt({ hash: txHash });
  if (!receipt.contractAddress) {
    throw new Error(
      "NFT Collection deployment failed - no contract address returned"
    );
  }
  return {
    collectionAddress: receipt.contractAddress,
    txHash,
    name,
    symbol,
    baseURI,
    maxSupply,
    deployer: agent.account.address
  };
}
async function deployNFTCollectionWithPreset(agent, preset, name, symbol, baseURI) {
  const presetConfigs = {
    pfp: 1e4,
    // Profile picture collections
    art: 1e3,
    // Art collections
    membership: 100,
    // Membership/pass collections
    unlimited: 0
    // Unlimited supply
  };
  return deployNFTCollection(agent, {
    name,
    symbol,
    baseURI,
    maxSupply: presetConfigs[preset]
  });
}
async function mintNFT(agent, collectionAddress, to) {
  const recipient = to || agent.account.address;
  if (agent.demo) {
    return {
      txHash: DEMO_TX_HASH,
      tokenId: "1",
      collectionAddress,
      to: recipient
    };
  }
  const data = viem.encodeFunctionData({
    abi: ERC721_ABI,
    functionName: "mint",
    args: [recipient]
  });
  const txHash = await agent.client.sendTransaction({
    to: collectionAddress,
    data
  });
  const receipt = await agent.client.waitForTransactionReceipt({ hash: txHash });
  let tokenId = "0";
  for (const log of receipt.logs) {
    if (log.topics[0] === "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef") {
      if (log.topics[3]) {
        tokenId = BigInt(log.topics[3]).toString();
      }
    }
  }
  return {
    txHash,
    tokenId,
    collectionAddress,
    to: recipient
  };
}
async function batchMintNFT(agent, collectionAddress, to, quantity) {
  if (agent.demo) {
    return {
      txHash: DEMO_TX_HASH,
      startTokenId: "1",
      quantity
    };
  }
  const data = viem.encodeFunctionData({
    abi: ERC721_ABI,
    functionName: "batchMint",
    args: [to, BigInt(quantity)]
  });
  const txHash = await agent.client.sendTransaction({
    to: collectionAddress,
    data
  });
  const receipt = await agent.client.waitForTransactionReceipt({ hash: txHash });
  let startTokenId = "1";
  for (const log of receipt.logs) {
    if (log.topics[0] === "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef") {
      if (log.topics[3]) {
        startTokenId = BigInt(log.topics[3]).toString();
        break;
      }
    }
  }
  return {
    txHash,
    startTokenId,
    quantity
  };
}
async function getNFTCollectionInfo(agent, collectionAddress, holderAddress) {
  if (agent.demo) {
    return {
      address: collectionAddress,
      name: "Demo NFT Collection",
      symbol: "DEMO",
      totalSupply: "100",
      balanceOf: holderAddress ? "5" : void 0
    };
  }
  const [name, symbol, totalSupply] = await Promise.all([
    agent.client.readContract({
      address: collectionAddress,
      abi: ERC721_ABI,
      functionName: "name"
    }),
    agent.client.readContract({
      address: collectionAddress,
      abi: ERC721_ABI,
      functionName: "symbol"
    }),
    agent.client.readContract({
      address: collectionAddress,
      abi: ERC721_ABI,
      functionName: "totalSupply"
    })
  ]);
  const result = {
    address: collectionAddress,
    name,
    symbol,
    totalSupply: totalSupply.toString()
  };
  if (holderAddress) {
    const balance = await agent.client.readContract({
      address: collectionAddress,
      abi: ERC721_ABI,
      functionName: "balanceOf",
      args: [holderAddress]
    });
    result.balanceOf = balance.toString();
  }
  return result;
}
async function getNFTTokenInfo(agent, collectionAddress, tokenId) {
  if (agent.demo) {
    return {
      collectionAddress,
      tokenId,
      owner: agent.account.address,
      tokenURI: `https://example.com/metadata/${tokenId}.json`
    };
  }
  const [owner, tokenURI] = await Promise.all([
    agent.client.readContract({
      address: collectionAddress,
      abi: ERC721_ABI,
      functionName: "ownerOf",
      args: [BigInt(tokenId)]
    }),
    agent.client.readContract({
      address: collectionAddress,
      abi: ERC721_ABI,
      functionName: "tokenURI",
      args: [BigInt(tokenId)]
    })
  ]);
  return {
    collectionAddress,
    tokenId,
    owner,
    tokenURI
  };
}
async function getNFTBalance(agent, collectionAddress, holderAddress) {
  const address = holderAddress || agent.account.address;
  if (agent.demo) {
    return "5";
  }
  const balance = await agent.client.readContract({
    address: collectionAddress,
    abi: ERC721_ABI,
    functionName: "balanceOf",
    args: [address]
  });
  return balance.toString();
}
async function isNFTOwner(agent, collectionAddress, tokenId, ownerAddress) {
  const address = ownerAddress || agent.account.address;
  if (agent.demo) {
    return true;
  }
  try {
    const owner = await agent.client.readContract({
      address: collectionAddress,
      abi: ERC721_ABI,
      functionName: "ownerOf",
      args: [BigInt(tokenId)]
    });
    return owner.toLowerCase() === address.toLowerCase();
  } catch {
    return false;
  }
}
async function transferNFT(agent, collectionAddress, to, tokenId) {
  if (agent.demo) {
    return DEMO_TX_HASH;
  }
  const data = viem.encodeFunctionData({
    abi: ERC721_ABI,
    functionName: "transferFrom",
    args: [agent.account.address, to, BigInt(tokenId)]
  });
  const txHash = await agent.client.sendTransaction({
    to: collectionAddress,
    data
  });
  await agent.client.waitForTransactionReceipt({ hash: txHash });
  return txHash;
}
async function safeTransferNFT(agent, collectionAddress, to, tokenId) {
  if (agent.demo) {
    return DEMO_TX_HASH;
  }
  const data = viem.encodeFunctionData({
    abi: ERC721_ABI,
    functionName: "safeTransferFrom",
    args: [agent.account.address, to, BigInt(tokenId)]
  });
  const txHash = await agent.client.sendTransaction({
    to: collectionAddress,
    data
  });
  await agent.client.waitForTransactionReceipt({ hash: txHash });
  return txHash;
}
async function approveNFT(agent, collectionAddress, approved, tokenId) {
  if (agent.demo) {
    return DEMO_TX_HASH;
  }
  const data = viem.encodeFunctionData({
    abi: ERC721_ABI,
    functionName: "approve",
    args: [approved, BigInt(tokenId)]
  });
  const txHash = await agent.client.sendTransaction({
    to: collectionAddress,
    data
  });
  await agent.client.waitForTransactionReceipt({ hash: txHash });
  return txHash;
}
async function setApprovalForAllNFT(agent, collectionAddress, operator, approved) {
  if (agent.demo) {
    return DEMO_TX_HASH;
  }
  const data = viem.encodeFunctionData({
    abi: ERC721_ABI,
    functionName: "setApprovalForAll",
    args: [operator, approved]
  });
  const txHash = await agent.client.sendTransaction({
    to: collectionAddress,
    data
  });
  await agent.client.waitForTransactionReceipt({ hash: txHash });
  return txHash;
}
var getSwapQuote = async (agent, from, to, amount, slippagePercentage) => {
  if (agent.demo) {
    return createMockQuoteResponse("OKX", amount);
  }
  const chainIndex = agent.chain === "mainnet" ? "5000" : "5003";
  const userWalletAddress = agent.account.address;
  const decimals = await getTokenDecimals(chainIndex, from);
  const amountInWei = viem.parseUnits(amount, decimals).toString();
  return getSwapTransaction(
    from,
    to,
    amountInWei,
    userWalletAddress,
    chainIndex,
    slippagePercentage
  );
};

// src/utils/x402/index.ts
var DEFAULT_PLATFORM_URL = "https://mantle-devkit.vercel.app";
var cachedConfig = null;
var validationPromise = null;
function getPlatformBaseUrl() {
  if (typeof process !== "undefined" && process.env) {
    return process.env.PLATFORM_URL || process.env.NEXT_PUBLIC_PLATFORM_URL || DEFAULT_PLATFORM_URL;
  }
  return DEFAULT_PLATFORM_URL;
}
async function validateAppId(appId) {
  const baseUrl2 = getPlatformBaseUrl();
  const url = `${baseUrl2}/api/v1/validate?appId=${encodeURIComponent(appId)}`;
  const response = await fetch(url, {
    method: "GET",
    headers: { "Content-Type": "application/json" }
  });
  if (!response.ok) {
    if (response.status === 404) {
      throw new Error(
        "Platform: Project not found. Invalid APP_ID. Please check your APP_ID configuration."
      );
    }
    if (response.status === 401) {
      throw new Error(
        "Platform: Unauthorized. Invalid APP_ID. Please verify your APP_ID."
      );
    }
    throw new Error(
      `Platform: Validation failed: ${response.status} ${response.statusText}`
    );
  }
  const data = await response.json();
  if (!data.appId || !data.payTo || !data.network) {
    throw new Error("Platform: Invalid response - missing required fields");
  }
  if (data.status !== "ACTIVE") {
    throw new Error(
      `Platform: Project is not active. Current status: ${data.status}`
    );
  }
  return {
    appId: data.appId,
    name: data.name,
    payTo: data.payTo,
    network: data.network,
    status: data.status
  };
}
async function initializePlatform() {
  if (cachedConfig) {
    return cachedConfig;
  }
  if (validationPromise) {
    return validationPromise;
  }
  let appId;
  if (typeof process !== "undefined" && process.env) {
    appId = process.env.APP_ID || process.env.NEXT_PUBLIC_APP_ID;
  }
  if (!appId || typeof appId !== "string" || appId.trim().length === 0) {
    throw new Error(
      "APP_ID is required. Set it in your .env file:\nAPP_ID=your_app_id_here"
    );
  }
  validationPromise = validateAppId(appId.trim());
  try {
    cachedConfig = await validationPromise;
    return cachedConfig;
  } catch (error) {
    validationPromise = null;
    throw error;
  }
}
function getProjectConfig() {
  if (!cachedConfig) {
    throw new Error(
      "Platform not initialized. Call initializePlatform() first."
    );
  }
  return cachedConfig;
}
async function getUserAccountData(agent, userAddress) {
  const lendingPoolAddress = LENDING_POOL[agent.chain];
  const address = userAddress || agent.account.address;
  if (lendingPoolAddress === "0x0000000000000000000000000000000000000000") {
    throw new Error(
      `Lendle LendingPool not configured for ${agent.chain}. Only available on mainnet.`
    );
  }
  const result = await agent.client.readContract({
    address: lendingPoolAddress,
    abi: LENDING_POOL_ABI,
    functionName: "getUserAccountData",
    args: [address]
  });
  return {
    totalCollateralETH: result[0],
    totalDebtETH: result[1],
    availableBorrowsETH: result[2],
    currentLiquidationThreshold: result[3],
    ltv: result[4],
    healthFactor: result[5]
  };
}
var MNTAgentKit = class {
  account;
  client;
  chain;
  demo;
  projectConfig;
  constructor(privateKey, chain) {
    this.account = accounts.privateKeyToAccount(privateKey);
    this.demo = chain === "testnet-demo";
    this.chain = chain === "testnet-demo" ? "testnet" : chain;
    this.client = viem.createWalletClient({
      chain: this.chain == "mainnet" ? chains.mantle : chains.mantleSepoliaTestnet,
      transport: viem.http(),
      account: this.account
    }).extend(viem.publicActions).extend(experimental.erc7811Actions());
  }
  /**
   * Initialize the agent with platform validation
   *
   * Validates APP_ID with the platform API.
   * Must be called after creating the agent instance.
   *
   * @returns The initialized agent instance
   * @throws Error if APP_ID is not set or validation fails
   *
   * @example
   * ```typescript
   * const agent = new MNTAgentKit(privateKey, "mainnet");
   * await agent.initialize(); // Validates APP_ID
   * ```
   */
  async initialize() {
    this.projectConfig = await initializePlatform();
    return this;
  }
  async sendTransaction(to, amount) {
    return await sendTransaction(this, to, amount);
  }
  // OKX DEX Aggregator
  async getSwapQuote(fromTokenAddress, toTokenAddress, amount, slippagePercentage = "0.5") {
    return await getSwapQuote(
      this,
      fromTokenAddress,
      toTokenAddress,
      amount,
      slippagePercentage
    );
  }
  async getTokens() {
    const chainIndex = this.chain === "mainnet" ? "5000" : "5003";
    return await getTokens(chainIndex);
  }
  async executeSwap(fromTokenAddress, toTokenAddress, amount, slippagePercentage = "0.5") {
    return await executeSwap(
      this,
      fromTokenAddress,
      toTokenAddress,
      amount,
      slippagePercentage
    );
  }
  // OpenOcean DEX Aggregator
  async getOpenOceanQuote(fromToken, toToken, amount) {
    return await getOpenOceanQuote(this, fromToken, toToken, amount);
  }
  async swapOnOpenOcean(fromToken, toToken, amount, slippage = 0.5) {
    return await swapOnOpenOcean(
      this,
      fromToken,
      toToken,
      amount,
      slippage.toString()
    );
  }
  async getOpenOceanTokens() {
    return await getTokenList(this.chain);
  }
  // Uniswap V3 DEX
  async getUniswapQuote(fromToken, toToken, amount) {
    return await getUniswapQuote(this, fromToken, toToken, amount);
  }
  async swapOnUniswap(fromToken, toToken, amount, slippage = 0.5) {
    return await swapOnUniswap(
      this,
      fromToken,
      toToken,
      amount,
      slippage.toString()
    );
  }
  // Lendle Lending Protocol
  async lendleSupply(tokenAddress, amount) {
    return await lendleSupply(this, tokenAddress, amount);
  }
  async lendleWithdraw(tokenAddress, amount, to) {
    return await lendleWithdraw(this, tokenAddress, amount, to);
  }
  async lendleBorrow(tokenAddress, amount, interestRateMode = 2, onBehalfOf) {
    return await lendleBorrow(
      this,
      tokenAddress,
      amount,
      interestRateMode,
      onBehalfOf
    );
  }
  async lendleRepay(tokenAddress, amount, rateMode = 2, onBehalfOf) {
    return await lendleRepay(this, tokenAddress, amount, rateMode, onBehalfOf);
  }
  /**
   * Get user account data from Lendle LendingPool
   * Returns overall position including total collateral, debt, and health factor
   * @param userAddress - User wallet address (optional, defaults to agent account)
   * @returns User account data with collateral, debt, available borrows, and health factor
   */
  async lendleGetUserAccountData(userAddress) {
    return await getUserAccountData(this, userAddress);
  }
  /**
   * Get all Lendle positions for a user (per-token breakdown)
   * Returns detailed supply and borrow amounts for each asset
   * @param userAddress - User wallet address (optional, defaults to agent account)
   * @returns Array of positions with supply/borrow amounts per asset
   */
  async lendleGetPositions(userAddress) {
    return await lendleGetPositions(this, userAddress);
  }
  // Agni Finance DEX (#1 on Mantle)
  async agniSwap(tokenIn, tokenOut, amountIn, slippagePercent = 0.5, feeTier) {
    return await agniSwap(
      this,
      tokenIn,
      tokenOut,
      amountIn,
      slippagePercent,
      feeTier
    );
  }
  // Merchant Moe DEX (#2 on Mantle)
  async merchantMoeSwap(tokenIn, tokenOut, amountIn, slippagePercent = 0.5, binStep) {
    return await merchantMoeSwap(
      this,
      tokenIn,
      tokenOut,
      amountIn,
      slippagePercent,
      binStep
    );
  }
  // mETH Protocol - Liquid Staking Token
  getMethTokenAddress() {
    if (this.demo) {
      return METH_TOKEN.mainnet;
    }
    return METH_TOKEN[this.chain];
  }
  /**
   * Get mETH staking position for a user
   * Returns mETH balance and WETH balance for comparison
   * @param userAddress - User wallet address (optional, defaults to agent account)
   * @returns mETH position with balances
   */
  async methGetPosition(userAddress) {
    return await methGetPosition(this, userAddress);
  }
  /**
   * Swap WETH to mETH using DEX aggregator
   * @param amount - Amount of WETH to swap (in wei as string)
   * @param slippage - Slippage tolerance percentage (default 0.5%)
   * @returns Transaction hash
   */
  async swapToMeth(amount, slippage = 0.5) {
    return await swapToMeth(this, amount, slippage);
  }
  /**
   * Swap mETH to WETH using DEX aggregator
   * @param amount - Amount of mETH to swap (in wei as string)
   * @param slippage - Slippage tolerance percentage (default 0.5%)
   * @returns Transaction hash
   */
  async swapFromMeth(amount, slippage = 0.5) {
    return await swapFromMeth(this, amount, slippage);
  }
  // Squid Router Cross-chain
  async getSquidRoute(fromToken, toToken, fromChain, toChain, amount, slippage = 1) {
    return await getSquidRoute(
      this,
      fromToken,
      toToken,
      fromChain,
      toChain,
      amount,
      slippage
    );
  }
  async crossChainSwapViaSquid(fromToken, toToken, fromChain, toChain, amount, slippage = 1) {
    return await crossChainSwapViaSquid(
      this,
      fromToken,
      toToken,
      fromChain,
      toChain,
      amount,
      slippage
    );
  }
  // PikePerps - Perpetual Trading
  /**
   * Open a long position on PikePerps
   * @param tokenAddress - Token to trade (meme token address)
   * @param margin - Margin amount in wei (as string)
   * @param leverage - Leverage multiplier (1-100, default 10)
   * @returns Position ID and transaction hash
   */
  async pikeperpsOpenLong(tokenAddress, margin, leverage = 10) {
    return await pikeperpsOpenLong(this, tokenAddress, margin, leverage);
  }
  /**
   * Open a short position on PikePerps
   * @param tokenAddress - Token to trade (meme token address)
   * @param margin - Margin amount in wei (as string)
   * @param leverage - Leverage multiplier (1-100, default 10)
   * @returns Position ID and transaction hash
   */
  async pikeperpsOpenShort(tokenAddress, margin, leverage = 10) {
    return await pikeperpsOpenShort(this, tokenAddress, margin, leverage);
  }
  /**
   * Close an existing position on PikePerps
   * @param positionId - Position ID to close
   * @returns Transaction hash
   */
  async pikeperpsClosePosition(positionId) {
    return await pikeperpsClosePosition(this, positionId);
  }
  /**
   * Get all positions for a user on PikePerps
   * Returns detailed position data including PnL and liquidation prices
   * @param userAddress - User wallet address (optional, defaults to agent account)
   * @returns Array of positions with PnL and liquidation data
   */
  async pikeperpsGetPositions(userAddress) {
    return await pikeperpsGetPositions(this, userAddress);
  }
  /**
   * Get market data for a token on PikePerps
   * Returns current price and recent trades
   * @param tokenAddress - Token address to get market data for
   * @param limit - Maximum number of recent trades to return (default 20)
   * @returns Market data with price and recent trades
   */
  async pikeperpsGetMarketData(tokenAddress, limit = 20) {
    return await pikeperpsGetMarketData(this, tokenAddress, limit);
  }
  // ===== Pyth Network Price Feeds =====
  /**
   * Get real-time price from Pyth Network
   * Accepts token address, pair name, or price feed ID
   * @param input - Token address (e.g., "0x09Bc4E0D10C81b3a3766c49F0f98a8aaa7adA8D2" for USDC),
   *                pair name (e.g., "ETH/USD"), or price feed ID (hex string)
   * @returns Price data with formatted price
   * @example
   * // Using pair name
   * await agent.pythGetPrice("ETH/USD");
   * // Using token address (USDC on Mantle)
   * await agent.pythGetPrice("0x09Bc4E0D10C81b3a3766c49F0f98a8aaa7adA8D2");
   */
  async pythGetPrice(input) {
    return await pythGetPrice(this, input);
  }
  /**
   * Get EMA (Exponential Moving Average) price from Pyth
   * Accepts token address, pair name, or price feed ID
   * @param input - Token address, pair name, or price feed ID
   * @returns EMA price data
   */
  async pythGetEmaPrice(input) {
    return await pythGetEmaPrice(this, input);
  }
  /**
   * Get price for a token by its contract address
   * Pass any supported token address and get the USD price with full details
   * @param tokenAddress - Token contract address on Mantle
   * @returns Token price details including symbol, USD price, and timestamp
   * @example
   * const price = await agent.pythGetTokenPrice("0x09Bc4E0D10C81b3a3766c49F0f98a8aaa7adA8D2");
   * // Returns: {
   * //   tokenAddress: "0x09Bc4E0D10C81b3a3766c49F0f98a8aaa7adA8D2",
   * //   tokenSymbol: "USDC",
   * //   pair: "USDC/USD",
   * //   priceUsd: "1.00",
   * //   lastUpdated: "2024-01-08T12:00:00.000Z"
   * // }
   */
  async pythGetTokenPrice(tokenAddress) {
    return await pythGetTokenPrice(this, tokenAddress);
  }
  /**
   * Get multiple prices from Pyth in a single call
   * Accepts token addresses, pair names, or price feed IDs
   * @param inputs - Array of token addresses, pair names, or price feed IDs
   * @returns Array of price responses
   * @example
   * await agent.pythGetMultiplePrices([
   *   "ETH/USD",                                           // pair name
   *   "0x09Bc4E0D10C81b3a3766c49F0f98a8aaa7adA8D2",       // USDC address
   *   "0xcDA86A272531e8640cD7F1a92c01839911B90bb0",       // mETH address
   * ]);
   */
  async pythGetMultiplePrices(inputs) {
    return await pythGetMultiplePrices(this, inputs);
  }
  /**
   * Get all supported Pyth price feed IDs
   * @returns Object mapping pair names to price feed IDs
   */
  pythGetSupportedPriceFeeds() {
    return pythGetSupportedPriceFeeds();
  }
  /**
   * Get all supported token addresses for Pyth price lookups on Mantle
   * @returns Object mapping token addresses to their pair names
   * @example
   * const addresses = agent.pythGetSupportedTokenAddresses();
   * // Returns: { "0x09Bc4E0D10C81b3a3766c49F0f98a8aaa7adA8D2": "USDC/USD", ... }
   */
  pythGetSupportedTokenAddresses() {
    return pythGetSupportedTokenAddresses();
  }
  /**
   * Check if a price feed exists on Pyth
   * Accepts token address, pair name, or price feed ID
   * @param input - Token address, pair name, or price feed ID
   * @returns Boolean indicating if feed exists
   */
  async pythPriceFeedExists(input) {
    return await pythPriceFeedExists(this, input);
  }
  // ===== Token Launchpad =====
  /**
   * Deploy a new token (ERC20 or RWA) - supply minted to your address
   * @param name - Token name
   * @param symbol - Token symbol
   * @param supply - Total supply (human readable, e.g., "1000000")
   * @param tokenType - "standard" or "rwa"
   * @param assetType - For RWA: asset category
   * @param assetId - For RWA: external asset ID
   */
  async deployToken(name, symbol, supply, tokenType = "standard", assetType, assetId) {
    return await deployToken(this, name, symbol, supply, tokenType, assetType, assetId);
  }
  /**
   * Deploy a standard ERC20 token
   * @param name - Token name
   * @param symbol - Token symbol
   * @param supply - Total supply (e.g., "1000000" for 1M tokens)
   */
  async deployStandardToken(name, symbol, supply) {
    return await deployStandardToken(this, name, symbol, supply);
  }
  /**
   * Deploy an RWA (Real World Asset) token
   * @param name - Token name (e.g., "Manhattan Property Token")
   * @param symbol - Token symbol (e.g., "MPT")
   * @param supply - Total supply for fractional ownership
   * @param assetType - Asset category: "Real Estate", "Commodities", "Securities", "Art"
   * @param assetId - External reference ID for the underlying asset
   */
  async deployRWAToken(name, symbol, supply, assetType, assetId) {
    return await deployRWAToken(this, name, symbol, supply, assetType, assetId);
  }
  /**
   * Get token information
   */
  async getTokenInfo(tokenAddress, holder) {
    return await getTokenInfo(this, tokenAddress, holder);
  }
  /**
   * Get token balance
   */
  async getTokenBalance(tokenAddress, holder) {
    return await getTokenBalance(this, tokenAddress, holder);
  }
  /**
   * Transfer tokens
   */
  async transferToken(tokenAddress, to, amount) {
    return await transferToken(this, tokenAddress, to, amount);
  }
  // ===== NFT Launchpad =====
  /**
   * Deploy a new ERC721 NFT collection on Mantle Network
   * @param config - Collection configuration (name, symbol, baseURI, maxSupply)
   * @returns Collection deployment result with contract address
   */
  async deployNFTCollection(config) {
    return await deployNFTCollection(this, config);
  }
  /**
   * Deploy an NFT collection with preset configurations
   * @param preset - Preset type: "pfp" (10000), "art" (1000), "membership" (100), "unlimited"
   * @param name - Collection name
   * @param symbol - Collection symbol
   * @param baseURI - Base URI for metadata
   * @returns Collection deployment result
   */
  async deployNFTCollectionWithPreset(preset, name, symbol, baseURI) {
    return await deployNFTCollectionWithPreset(
      this,
      preset,
      name,
      symbol,
      baseURI
    );
  }
  /**
   * Mint a single NFT from a collection
   * @param collectionAddress - NFT collection contract address
   * @param to - Recipient address (defaults to agent address)
   * @returns Mint result with token ID
   */
  async mintNFT(collectionAddress, to) {
    return await mintNFT(this, collectionAddress, to);
  }
  /**
   * Batch mint multiple NFTs from a collection
   * @param collectionAddress - NFT collection contract address
   * @param to - Recipient address
   * @param quantity - Number of NFTs to mint
   * @returns Mint result with starting token ID
   */
  async batchMintNFT(collectionAddress, to, quantity) {
    return await batchMintNFT(this, collectionAddress, to, quantity);
  }
  /**
   * Get information about an NFT collection
   * @param collectionAddress - NFT collection contract address
   * @param holderAddress - Optional address to get balance for
   * @returns Collection information
   */
  async getNFTCollectionInfo(collectionAddress, holderAddress) {
    return await getNFTCollectionInfo(this, collectionAddress, holderAddress);
  }
  /**
   * Get information about a specific NFT token
   * @param collectionAddress - NFT collection contract address
   * @param tokenId - Token ID
   * @returns Token information
   */
  async getNFTTokenInfo(collectionAddress, tokenId) {
    return await getNFTTokenInfo(this, collectionAddress, tokenId);
  }
  /**
   * Get NFT balance for an address
   * @param collectionAddress - NFT collection contract address
   * @param holderAddress - Address to check (defaults to agent address)
   * @returns Balance as string
   */
  async getNFTBalance(collectionAddress, holderAddress) {
    return await getNFTBalance(this, collectionAddress, holderAddress);
  }
  /**
   * Check if an address owns a specific NFT
   * @param collectionAddress - NFT collection contract address
   * @param tokenId - Token ID to check
   * @param ownerAddress - Address to verify ownership
   * @returns Boolean indicating ownership
   */
  async isNFTOwner(collectionAddress, tokenId, ownerAddress) {
    return await isNFTOwner(this, collectionAddress, tokenId, ownerAddress);
  }
  /**
   * Transfer an NFT to another address
   * @param collectionAddress - NFT collection contract address
   * @param to - Recipient address
   * @param tokenId - Token ID to transfer
   * @returns Transaction hash
   */
  async transferNFT(collectionAddress, to, tokenId) {
    return await transferNFT(this, collectionAddress, to, tokenId);
  }
  /**
   * Safe transfer an NFT (checks if recipient can receive)
   * @param collectionAddress - NFT collection contract address
   * @param to - Recipient address
   * @param tokenId - Token ID to transfer
   * @returns Transaction hash
   */
  async safeTransferNFT(collectionAddress, to, tokenId) {
    return await safeTransferNFT(this, collectionAddress, to, tokenId);
  }
  /**
   * Approve an address to transfer a specific NFT
   * @param collectionAddress - NFT collection contract address
   * @param approved - Address to approve
   * @param tokenId - Token ID to approve
   * @returns Transaction hash
   */
  async approveNFT(collectionAddress, approved, tokenId) {
    return await approveNFT(this, collectionAddress, approved, tokenId);
  }
  /**
   * Set approval for all NFTs in a collection
   * @param collectionAddress - NFT collection contract address
   * @param operator - Operator address
   * @param approved - Whether to approve or revoke
   * @returns Transaction hash
   */
  async setApprovalForAllNFT(collectionAddress, operator, approved) {
    return await setApprovalForAllNFT(this, collectionAddress, operator, approved);
  }
};

exports.AgniConstants = agni_exports;
exports.LendleConstants = lendle_exports;
exports.METH_TOKEN = METH_TOKEN;
exports.MNTAgentKit = MNTAgentKit;
exports.MerchantMoeConstants = merchantmoe_exports;
exports.MethConstants = meth_exports;
exports.NFTLaunchpadConstants = nft_launchpad_exports;
exports.OKXConstants = okx_exports;
exports.OpenOceanConstants = openocean_exports;
exports.PikePerpsConstants = pikeperps_exports;
exports.PythConstants = pyth_exports;
exports.SquidConstants = squid_exports;
exports.TokenLaunchpadConstants = token_launchpad_exports;
exports.UniswapConstants = uniswap_exports;
exports.agniSwap = agniSwap;
exports.approveNFT = approveNFT;
exports.approveToken = approveToken;
exports.batchMintNFT = batchMintNFT;
exports.crossChainSwapViaSquid = crossChainSwapViaSquid;
exports.deployNFTCollection = deployNFTCollection;
exports.deployNFTCollectionWithPreset = deployNFTCollectionWithPreset;
exports.deployRWAToken = deployRWAToken;
exports.deployStandardToken = deployStandardToken;
exports.deployToken = deployToken;
exports.executeSwap = executeSwap;
exports.getNFTBalance = getNFTBalance;
exports.getNFTCollectionInfo = getNFTCollectionInfo;
exports.getNFTTokenInfo = getNFTTokenInfo;
exports.getOpenOceanQuote = getOpenOceanQuote;
exports.getProjectConfig = getProjectConfig;
exports.getSquidRoute = getSquidRoute;
exports.getTokenBalance = getTokenBalance;
exports.getTokenInfo = getTokenInfo;
exports.getUniswapQuote = getUniswapQuote;
exports.initializePlatform = initializePlatform;
exports.isNFTOwner = isNFTOwner;
exports.lendleBorrow = lendleBorrow;
exports.lendleGetPositions = lendleGetPositions;
exports.lendleRepay = lendleRepay;
exports.lendleSupply = lendleSupply;
exports.lendleWithdraw = lendleWithdraw;
exports.merchantMoeSwap = merchantMoeSwap;
exports.methGetPosition = methGetPosition;
exports.mintNFT = mintNFT;
exports.pikeperpsClosePosition = pikeperpsClosePosition;
exports.pikeperpsGetMarketData = pikeperpsGetMarketData;
exports.pikeperpsGetPositions = pikeperpsGetPositions;
exports.pikeperpsOpenLong = pikeperpsOpenLong;
exports.pikeperpsOpenShort = pikeperpsOpenShort;
exports.pythGetEmaPrice = pythGetEmaPrice;
exports.pythGetMultiplePrices = pythGetMultiplePrices;
exports.pythGetPrice = pythGetPrice;
exports.pythGetSupportedPriceFeeds = pythGetSupportedPriceFeeds;
exports.pythGetSupportedTokenAddresses = pythGetSupportedTokenAddresses;
exports.pythGetTokenPrice = pythGetTokenPrice;
exports.pythPriceFeedExists = pythPriceFeedExists;
exports.safeTransferNFT = safeTransferNFT;
exports.sendTransaction = sendTransaction;
exports.setApprovalForAllNFT = setApprovalForAllNFT;
exports.swapFromMeth = swapFromMeth;
exports.swapOnOpenOcean = swapOnOpenOcean;
exports.swapOnUniswap = swapOnUniswap;
exports.swapToMeth = swapToMeth;
exports.transferNFT = transferNFT;
exports.transferToken = transferToken;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map